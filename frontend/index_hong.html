<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Earth Orbit Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
    }
  }
  </script>

  <style>
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(0, 0, 0, 0.6);
      color: #ffffff;
      padding: 12px 14px;
      border-radius: 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 14px;
      display: grid;
      gap: 8px;
      z-index: 10;
      backdrop-filter: blur(6px);
    }
    #ui .row {
      display: flex;
      align-items: flex-end;
      gap: 8px;
    }
    #flight-select {
      display: grid;
      gap: 6px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.04);
    }
    #flight-select .section-title {
      font-size: 14px;
      font-weight: 600;
      opacity: 0.95;
    }
    #ui .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    #ui .field label {
      font-size: 12px;
      opacity: 0.8;
    }
    #ui .label-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
      vertical-align: middle;
    }
    #ui .label-dot.green { background: #00ff7f; }
    #ui .label-dot.red { background: #ff5555; }
    #brand {
      position: absolute;
      top: 12px;
      left: 16px;
      font-family: 'Arial Black', 'Impact', system-ui, sans-serif;
      font-size: 20px;
      font-weight: 800;
      letter-spacing: 2px;
      color: #ffffff;
      text-decoration: none;
      z-index: 12;
    }
    #brand:hover {
      opacity: 0.85;
    }
    #time-ui {
      position: absolute;
      bottom: 16px;
      right: 16px;
      background: rgba(0, 0, 0, 0.6);
      color: #ffffff;
      padding: 10px 12px;
      border-radius: 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 14px;
      display: grid;
      gap: 6px;
      z-index: 10;
      backdrop-filter: blur(6px);
    }
    #time-ui .time-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #toggleTimeFlow {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
      cursor: pointer;
      white-space: nowrap;
    }
    #time-ui label {
      font-size: 12px;
      opacity: 0.8;
    }
    #time-ui input {
      font-size: 14px;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
    }
    #time-ui input::-webkit-calendar-picker-indicator {
      filter: invert(1);
    }
    #time-ui .pred-section {
      display: grid;
      gap: 6px;
      margin-bottom: 6px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.04);
    }
    #time-ui .pred-title {
      font-size: 14px;
      font-weight: 600;
      opacity: 0.95;
    }
    #time-ui .pred-value {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 72px;
      min-height: 28px;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(0,0,0,0.2);
      font-size: 14px;
    }
    #time-ui .pred-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      opacity: 0.9;
    }
    #time-ui .pred-table th {
      font-weight: 600;
    }
    #time-ui .pred-table th,
    #time-ui .pred-table td {
      padding: 4px 0;
      text-align: left;
    }
    #radiation-panel {
      position: absolute;
      bottom: 16px;
      left: 16px;
      background: rgba(0, 0, 0, 0.6);
      color: #ffffff;
      padding: 12px 14px;
      border-radius: 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 14px;
      display: grid;
      gap: 8px;
      z-index: 10;
      backdrop-filter: blur(6px);
      min-width: 240px;
    }
    #ui select, #ui button {
      font-size: 14px;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
    }
    #ui button {
      cursor: pointer;
      border-color: #2aa3ff;
      background: #2aa3ff;
      color: #000;
      font-weight: 600;
    }
    #ui .arrow {
      opacity: 0.7;
    }
    #profile {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      margin-bottom: 4px;
    }
    #profile button {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.1);
      color: #fff;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #profile-menu {
      position: absolute;
      top: 56px;
      right: 16px;
      background: #000000;
      color: #fff;
      border-radius: 10px;
      padding: 8px;
      display: none;
      flex-direction: column;
      gap: 6px;
      border: 1px solid rgba(255,255,255,0.15);
      z-index: 11;
      min-width: 140px;
    }
    #profile-menu button {
      background: transparent;
      color: #fff;
      border: none;
      text-align: left;
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
    }
    #profile-menu .menu-link {
      background: transparent;
      color: #fff;
      text-decoration: none;
      text-align: left;
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
      display: block;
    }
    #profile-menu button:hover {
      background: rgba(255,255,255,0.12);
    }
    #profile-menu .menu-link:hover {
      background: rgba(255,255,255,0.12);
    }

    #log-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
      backdrop-filter: blur(4px);
    }
    #log-modal.open {
      display: flex;
    }
    .modal-card {
      width: min(420px, 90vw);
      background: #0b0b0b;
      color: #fff;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.15);
      padding: 16px;
      display: grid;
      gap: 12px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.4);
    }
    .modal-title {
      font-size: 16px;
      font-weight: 700;
    }
    .modal-section {
      display: grid;
      gap: 8px;
    }
    .modal-subtitle {
      font-size: 13px;
      font-weight: 600;
      opacity: 0.95;
    }
    .modal-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      opacity: 0.9;
    }
    .modal-field {
      display: grid;
      gap: 6px;
      font-size: 12px;
    }
    .modal-field input {
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
      font-size: 13px;
    }
    #crew-list {
      display: grid;
      gap: 6px;
    }
    .crew-row {
      display: flex;
      gap: 6px;
    }
    .crew-row input {
      flex: 1;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
      font-size: 13px;
    }
    .crew-row button {
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.3);
      background: transparent;
      color: #fff;
      cursor: pointer;
    }
    #add-crew {
      align-self: flex-start;
      padding: 4px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.3);
      background: transparent;
      color: #fff;
      cursor: pointer;
      font-size: 12px;
    }
    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    .modal-actions button {
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid #2aa3ff;
      background: #2aa3ff;
      color: #000;
      font-weight: 600;
      cursor: pointer;
    }
    .modal-actions button.secondary {
      border-color: rgba(255,255,255,0.3);
      background: transparent;
      color: #fff;
    }

    /* === NEW: Radiation legend === */
    #legend {
      display: grid;
      gap: 6px;
    }
    #legend .title {
      font-size: 14px;
      font-weight: 600;
      opacity: 0.95;
    }
    #legend .bar {
      width: 100%;
      height: 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.22);
      background: linear-gradient(90deg, #2a6cff 0%, #37e0ff 25%, #7dff8d 50%, #ffd166 75%, #ff3b3b 100%);
    }
    #legend .labels {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      opacity: 0.85;
    }
    #route-info {
      margin-top: 8px;
      display: grid;
      gap: 4px;
      font-size: 12px;
      opacity: 0.9;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.04);
    }
    #route-info .section-title {
      font-size: 14px;
      font-weight: 600;
      opacity: 0.95;
      margin-bottom: 2px;
    }
    #route-info .row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
    #route-info .button-row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
      flex-wrap: wrap;
    }
    #route-info button {
      font-size: 14px;
      padding: 6px 14px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.1);
      color: #fff;
      cursor: pointer;
    }
  </style>
</head>
<body>
<a id="brand" href="./index.html">DDCAS</a>
<div id="time-ui">
  <div class="pred-section">
    <div class="pred-title">Tomorrow's Danger Prediction</div>
    <table class="pred-table">
      <thead>
        <tr><th>Probability</th><th>Intensity</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><span id="predEvent" class="pred-value">-</span></td>
          <td><span id="predIntensity" class="pred-value">-</span></td>
        </tr>
      </tbody>
    </table>
  </div>
  <label for="datetimeInput">Date & Time (GST)</label>
  <div class="time-row">
    <input id="datetimeInput" type="datetime-local" lang="en" step="1" />
    <button id="toggleTimeFlow" type="button">Pause</button>
  </div>
</div>
<div id="ui">
  <div id="profile">
    <button id="profileBtn" aria-label="Profile">J</button>
  </div>
  <div id="profile-menu">
    <button id="profile-page-link" class="menu-link" type="button">My Page</button>
    <button id="logout-button" type="button">Logout</button>
  </div>
  <div id="flight-select">
    <div class="section-title">Flight select</div>
    <div class="row">
      <div class="field">
        <label for="departSelect"><span class="label-dot green"></span>Depart</label>
        <select id="departSelect">
          <option value="">Select</option>
        </select>
      </div>
      <span class="arrow">→</span>
      <div class="field">
        <label for="arriveSelect"><span class="label-dot red"></span>Arrive</label>
        <select id="arriveSelect">
          <option value="">Select</option>
        </select>
      </div>
      <button id="showBtn">Show</button>
    </div>
  </div>
  <div id="route-info">
    <div class="section-title">Flight Information</div>
    <div class="row"><span>Average speed</span><span id="routeSpeed">900 km/h</span></div>
    <div class="row"><span>Distance</span><span id="routeDistance">-</span></div>
    <div class="row"><span>Flight time</span><span id="routeTime">-</span></div>
    <div class="row"><span>Total dose</span><span id="routeDose">-</span></div>
    <div class="button-row">
      <button id="addToLogBtn">Add to log</button>
      <button id="changeViewBtn" style="display:none;">Change view</button>
    </div>
  </div>

</div>

  <div id="radiation-panel">
  <div id="legend">
    <div class="title">Radiation overlay</div>
    <div class="bar" aria-label="radiation color legend"></div>
    <div class="labels">
      <span id="legendMin">min</span>
      <span id="legendMax">max</span>
    </div>
    <div class="row" style="display:flex; align-items:center; gap:6px;">
      <label style="display:flex; align-items:center; gap:6px;">
        <input type="checkbox" id="toggleRadiation" checked />
        Radiation overlay
      </label>
    </div>
  </div>
</div>

<div id="log-modal" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-title">Add Flight Log</div>
    <div class="modal-section">
      <label class="modal-row">
        <input id="useCurrentTime" type="checkbox" checked />
        Use current time
      </label>
      <label class="modal-field">
        <span>Date & Time (GST)</span>
        <input id="logDatetimeInput" type="datetime-local" step="1" />
      </label>
    </div>
    <div class="modal-section">
      <div class="modal-subtitle">Crew codes</div>
      <div id="crew-list"></div>
      <button id="add-crew" type="button">+ Add crew</button>
    </div>
    <div class="modal-actions">
      <button id="save-log" type="button">Save</button>
      <button id="cancel-log" type="button" class="secondary">Cancel</button>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// SCENE
const scene = new THREE.Scene();

// CAMERA
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 4);

// RENDERER
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.NoToneMapping;
document.body.appendChild(renderer.domElement);

// CONTROLS
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.enablePan = false;
controls.minDistance = 0.6;
controls.maxDistance = 8;
controls.target.set(0, 0, 0);
controls.update();
const defaultCameraState = {
  position: camera.position.clone(),
  target: controls.target.clone(),
};
let cameraTransition = null;

function startCameraTransition(position, target, up, durationMs = 800) {
  cameraTransition = {
    startTime: performance.now(),
    durationMs,
    startPosition: camera.position.clone(),
    startTarget: controls.target.clone(),
    startUp: camera.up.clone(),
    endPosition: position.clone(),
    endTarget: target.clone(),
    endUp: up.clone(),
  };
}

function updateCameraTransition() {
  if (!cameraTransition) return false;
  const now = performance.now();
  const elapsed = now - cameraTransition.startTime;
  const t = Math.min(1, elapsed / cameraTransition.durationMs);
  const eased = 0.5 - 0.5 * Math.cos(Math.PI * t);

  camera.position.lerpVectors(
    cameraTransition.startPosition,
    cameraTransition.endPosition,
    eased
  );
  controls.target.lerpVectors(
    cameraTransition.startTarget,
    cameraTransition.endTarget,
    eased
  );
  camera.up
    .lerpVectors(cameraTransition.startUp, cameraTransition.endUp, eased)
    .normalize();
  controls.update();

  if (t >= 1) {
    cameraTransition = null;
  }
  return true;
}

// BACKGROUND (sky sphere that rotates with earth)
const textureLoader = new THREE.TextureLoader();
const SKY_RADIUS = 50;
const skyTexture = textureLoader.load('./texture/8k_stars_milky_way.jpg');
skyTexture.colorSpace = THREE.SRGBColorSpace;
const sky = new THREE.Mesh(
  new THREE.SphereGeometry(SKY_RADIUS, 64, 64),
  new THREE.MeshBasicMaterial({ map: skyTexture, side: THREE.BackSide, depthWrite: false })
);
scene.add(sky);

const sunTexture = textureLoader.load('./texture/ssun.png');
sunTexture.colorSpace = THREE.SRGBColorSpace;
const sunSprite = new THREE.Sprite(
  new THREE.SpriteMaterial({
    map: sunTexture,
    color: 0xffffff,
    transparent: true,
    depthWrite: false,
  })
);
sunSprite.scale.set(SKY_RADIUS * 0.12, SKY_RADIUS * 0.12, 1);
scene.add(sunSprite);

// LIGHTS
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const sunLight = new THREE.DirectionalLight(0xffffff, 1);
scene.add(sunLight);

// EARTH
const EARTH_RADIUS = 1;
const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
const earthTexture = textureLoader.load('./texture/8k_earth_daymap.jpg');
earthTexture.colorSpace = THREE.SRGBColorSpace;

const earth = new THREE.Mesh(
  earthGeometry,
  new THREE.MeshStandardMaterial({ map: earthTexture })
);
scene.add(earth);

// MARKER
function latLonToVector3(lat, lon, radius) {
  const u = (lon + 180) / 360;
  const v = (90 - lat) / 180;

  const theta = v * Math.PI;
  const phi = u * Math.PI * 2;

  const sinTheta = Math.sin(theta);
  const x = -radius * Math.cos(phi) * sinTheta;
  const y =  radius * Math.cos(theta);
  const z =  radius * Math.sin(phi) * sinTheta;

  return new THREE.Vector3(x, y, z);
}

function latLonToUnitVector(lat, lon) {
  return latLonToVector3(lat, lon, 1).normalize();
}

function getSolarDeclination(dayOfYear) {
  return 23.44 * Math.sin(((2 * Math.PI) / 365) * (dayOfYear - 81));
}

function dayOfYearUTC(date) {
  const start = Date.UTC(date.getUTCFullYear(), 0, 0);
  const now = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
  return Math.floor((now - start) / 86400000);
}

function updateSunFromDate(date) {
  const doy = dayOfYearUTC(date);
  const declination = getSolarDeclination(doy);

  const hours =
    date.getUTCHours() +
    date.getUTCMinutes() / 60 +
    date.getUTCSeconds() / 3600;
  const subsolarLon = 180 - (hours * 15);

  const sunDir = latLonToUnitVector(declination, subsolarLon);
  sunLight.position.copy(sunDir.clone().multiplyScalar(5));
  sunSprite.position.copy(sunDir.clone().multiplyScalar(SKY_RADIUS - 1));
  sunLight.target.position.set(0, 0, 0);
  sunLight.target.updateMatrixWorld();
}

const startMarker = new THREE.Mesh(
  new THREE.SphereGeometry(0.015, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0x00ff7f })
);
const endMarker = new THREE.Mesh(
  new THREE.SphereGeometry(0.015, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0xff5555 })
);
startMarker.visible = false;
endMarker.visible = false;
scene.add(startMarker);
scene.add(endMarker);

let currentRouteLine = null;

function greatCircleKm(lat1, lon1, lat2, lon2) {
  const r = 6371.0088;
  const toRad = (v) => (v * Math.PI) / 180;
  const phi1 = toRad(lat1);
  const phi2 = toRad(lat2);
  const dPhi = toRad(lat2 - lat1);
  const dLambda = toRad(lon2 - lon1);
  const a = Math.sin(dPhi / 2) ** 2 +
    Math.cos(phi1) * Math.cos(phi2) * Math.sin(dLambda / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return r * c;
}

function buildArcPoints(lat1, lon1, lat2, lon2, segments = 64) {
  const start = latLonToVector3(lat1, lon1, 1).normalize();
  const end = latLonToVector3(lat2, lon2, 1).normalize();
  const dot = Math.min(1, Math.max(-1, start.dot(end)));
  const omega = Math.acos(dot);
  const sinOmega = Math.sin(omega);
  const points = [];
  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    let p;
    if (sinOmega < 1e-6) {
      p = start.clone().lerp(end, t).normalize();
    } else {
      const a = Math.sin((1 - t) * omega) / sinOmega;
      const b = Math.sin(t * omega) / sinOmega;
      p = start.clone().multiplyScalar(a).add(end.clone().multiplyScalar(b)).normalize();
    }
    p.multiplyScalar(EARTH_RADIUS + 0.02);
    points.push(p);
  }
  return points;
}

function vectorToLatLon(v) {
  const lat = 90 - Math.acos(v.y) * 180 / Math.PI;
  const lon = Math.atan2(v.z, -v.x) * 180 / Math.PI;
  return { lat, lon };
}

function sampleRadiationAt(grid, lat, lon) {
  if (!grid) return null;
  const { width, height, latStep, lonStep, values } = grid;
  let wrappedLon = lon;
  if (wrappedLon < -180) wrappedLon += 360;
  if (wrappedLon >= 180) wrappedLon -= 360;
  const x = Math.min(width - 1, Math.max(0, Math.floor((wrappedLon + 180) / lonStep)));
  const y = Math.min(height - 1, Math.max(0, Math.floor((90 - lat) / latStep)));
  return values[y * width + x];
}

function computeRouteDose(route, grid) {
  const distanceKm = greatCircleKm(route.srcLat, route.srcLon, route.dstLat, route.dstLon);
  const hours = distanceKm / 900;
  const segments = Math.max(64, Math.ceil(distanceKm / 200));

  const start = latLonToVector3(route.srcLat, route.srcLon, 1).normalize();
  const end = latLonToVector3(route.dstLat, route.dstLon, 1).normalize();
  const dot = Math.min(1, Math.max(-1, start.dot(end)));
  const omega = Math.acos(dot);
  const sinOmega = Math.sin(omega);

  let totalMicroSv = 0;
  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    let p;
    if (sinOmega < 1e-6) {
      p = start.clone().lerp(end, t).normalize();
    } else {
      const a = Math.sin((1 - t) * omega) / sinOmega;
      const b = Math.sin(t * omega) / sinOmega;
      p = start.clone().multiplyScalar(a).add(end.clone().multiplyScalar(b)).normalize();
    }
    const { lat, lon } = vectorToLatLon(p);
    const rate = sampleRadiationAt(grid, lat, lon);
    if (rate != null) {
      totalMicroSv += rate;
    }
  }

  const avgRate = totalMicroSv / (segments + 1);
  const doseMicroSv = avgRate * hours;
  const doseSv = doseMicroSv * 1e-6;

  return { distanceKm, hours, doseMicroSv, doseSv };
}

function drawRoute(route) {
  if (currentRouteLine) {
    scene.remove(currentRouteLine);
    currentRouteLine.geometry.dispose();
    currentRouteLine.material.dispose();
    currentRouteLine = null;
  }

  const points = buildArcPoints(route.srcLat, route.srcLon, route.dstLat, route.dstLon);
  const routeGeometry = new THREE.BufferGeometry().setFromPoints(points);
  const routeMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
  currentRouteLine = new THREE.Line(routeGeometry, routeMaterial);
  scene.add(currentRouteLine);

  startMarker.position.copy(latLonToVector3(route.srcLat, route.srcLon, EARTH_RADIUS + 0.02));
  endMarker.position.copy(latLonToVector3(route.dstLat, route.dstLon, EARTH_RADIUS + 0.02));
  startMarker.visible = true;
  endMarker.visible = true;
}

function setRouteCenteredView(route) {
  const start = latLonToVector3(route.srcLat, route.srcLon, EARTH_RADIUS);
  const end = latLonToVector3(route.dstLat, route.dstLon, EARTH_RADIUS);
  let midUnit = start.clone().normalize().add(end.clone().normalize());
  if (midUnit.lengthSq() < 1e-6) {
    midUnit = start.clone().normalize();
  }
  midUnit.normalize();

  const target = midUnit.clone().multiplyScalar(EARTH_RADIUS);
  let radius = 0;
  for (const p of [start, end]) {
    radius = Math.max(radius, target.distanceTo(p));
  }

  const verticalFov = THREE.MathUtils.degToRad(camera.fov);
  const horizontalFov = 2 * Math.atan(Math.tan(verticalFov / 2) * camera.aspect);
  const minFov = Math.min(verticalFov, horizontalFov);
  const distance = Math.max(EARTH_RADIUS * 1.1, (radius * 1.35) / Math.tan(minFov / 2));

  const desiredPosition = target.clone().add(midUnit.multiplyScalar(distance));
  const desiredTarget = target.clone();
  const desiredUp = new THREE.Vector3(0, 1, 0);
  startCameraTransition(desiredPosition, desiredTarget, desiredUp, 900);
}

function resetCameraView() {
  if (currentRoute) {
    setRouteCenteredView(currentRoute);
    return;
  }
  startCameraTransition(
    defaultCameraState.position.clone(),
    defaultCameraState.target.clone(),
    new THREE.Vector3(0, 1, 0),
    900
  );
}

function setRouteSideView(route) {
  const start = latLonToVector3(route.srcLat, route.srcLon, EARTH_RADIUS);
  const end = latLonToVector3(route.dstLat, route.dstLon, EARTH_RADIUS);
  const startUnit = start.clone().normalize();
  const endUnit = end.clone().normalize();

  let midUnit = startUnit.clone().add(endUnit);
  if (midUnit.lengthSq() < 1e-6) {
    midUnit = startUnit.clone();
  }
  midUnit.normalize();

  let planeNormal = startUnit.clone().cross(endUnit);
  if (planeNormal.lengthSq() < 1e-6) {
    planeNormal = new THREE.Vector3(0, 1, 0).cross(midUnit);
  }
  planeNormal.normalize();

  const tiltRad = THREE.MathUtils.degToRad(28);
  const viewDir = planeNormal.clone()
    .multiplyScalar(Math.cos(tiltRad))
    .add(midUnit.clone().multiplyScalar(Math.sin(tiltRad)))
    .normalize();
  const targetOffset = 0.0;
  const target = midUnit.clone().multiplyScalar(EARTH_RADIUS + targetOffset);

  let radius = 0;
  for (const p of [start, end]) {
    radius = Math.max(radius, target.distanceTo(p));
  }

  const verticalFov = THREE.MathUtils.degToRad(camera.fov);
  const horizontalFov = 2 * Math.atan(Math.tan(verticalFov / 2) * camera.aspect);
  const baseDistance = Math.max(
    EARTH_RADIUS * 1.0,
    (radius * 1.0) / Math.tan(horizontalFov / 2)
  );
  const distance = baseDistance * 0.45;

  const desiredPosition = target.clone().add(viewDir.multiplyScalar(distance));
  const desiredTarget = target.clone();
  const desiredUp = midUnit.clone();
  startCameraTransition(desiredPosition, desiredTarget, desiredUp, 900);
}

// UI + DATA
const departSelect = document.getElementById('departSelect');
const arriveSelect = document.getElementById('arriveSelect');
const showBtn = document.getElementById('showBtn');
const datetimeInput = document.getElementById('datetimeInput');
const toggleTimeFlow = document.getElementById('toggleTimeFlow');
const profileBtn = document.getElementById('profileBtn');
const profileMenu = document.getElementById('profile-menu');
const FLIGHT_RECORDS_KEY = 'ddcas_flight_records';
const LOGIN_STORAGE_KEY = 'ddcas_logged_in';
const CURRENT_USER_KEY = 'ddcas_current_user';
const CURRENT_ROLE_KEY = 'ddcas_current_role';
const CURRENT_CREW_CODE_KEY = 'ddcas_current_crew_code';
const logoutButton = document.getElementById('logout-button');
const profilePageLink = document.getElementById('profile-page-link');
const predEventEl = document.getElementById('predEvent');
const predIntensityEl = document.getElementById('predIntensity');

// NEW: legend elements
const legendMinEl = document.getElementById('legendMin');
const legendMaxEl = document.getElementById('legendMax');
const routeDistanceEl = document.getElementById('routeDistance');
const routeTimeEl = document.getElementById('routeTime');
const routeDoseEl = document.getElementById('routeDose');
const addToLogBtn = document.getElementById('addToLogBtn');
const changeViewBtn = document.getElementById('changeViewBtn');
const toggleRadiation = document.getElementById('toggleRadiation');
let isRouteSideView = false;

const logModal = document.getElementById('log-modal');
const useCurrentTime = document.getElementById('useCurrentTime');
const logDatetimeInput = document.getElementById('logDatetimeInput');
const crewListEl = document.getElementById('crew-list');
const addCrewBtn = document.getElementById('add-crew');
const saveLogBtn = document.getElementById('save-log');
const cancelLogBtn = document.getElementById('cancel-log');

function getCurrentUser() {
  return localStorage.getItem(CURRENT_USER_KEY) || 'guest';
}

function isLoggedIn() {
  return localStorage.getItem(LOGIN_STORAGE_KEY) === 'true' &&
    Boolean(localStorage.getItem(CURRENT_USER_KEY));
}

function getCurrentRole() {
  return localStorage.getItem(CURRENT_ROLE_KEY) || 'crew';
}

function applyRoleUI() {
  const role = getCurrentRole();
  addToLogBtn.style.display = isLoggedIn() && role === 'admin' ? 'inline-flex' : 'none';
  profilePageLink.textContent = role === 'admin' ? 'Status' : 'My Page';
  profileBtn.textContent = role === 'admin' ? 'ADMIN' : 'J';
}

function loadFlightRecords() {
  try {
    const raw = localStorage.getItem(FLIGHT_RECORDS_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : [];
  } catch (err) {
    console.warn('Failed to read flight records', err);
    return [];
  }
}

function saveFlightRecords(records) {
  localStorage.setItem(FLIGHT_RECORDS_KEY, JSON.stringify(records));
}

function parseDateTimeLocalAsUTC(value) {
  const match = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(?::(\d{2}))?$/.exec(value);
  if (!match) return null;
  const [, y, m, d, hh, mm, ss] = match;
  return new Date(Date.UTC(
    Number(y),
    Number(m) - 1,
    Number(d),
    Number(hh),
    Number(mm),
    Number(ss || 0)
  ));
}

let sepPredictionMap = null;

async function loadSepPredictions() {
  if (sepPredictionMap) return sepPredictionMap;
  const map = new Map();
  try {
    const res = await fetch('./forecast_sep/sep_pred_data/pred_2000.csv');
    if (!res.ok) throw new Error(`SEP csv load failed: ${res.status}`);
    const text = await res.text();
    const lines = text.trim().split('\n');
    lines.shift();
    for (const line of lines) {
      const [date, pEvent, intensity] = line.split(',');
      if (!date) continue;
      map.set(date.trim(), {
        pEvent: Number(pEvent),
        intensity: Number(intensity),
      });
    }
  } catch (err) {
    console.warn('Failed to load SEP predictions', err);
  }
  sepPredictionMap = map;
  return map;
}

function formatDateKey(date) {
  const y = date.getUTCFullYear();
  const m = String(date.getUTCMonth() + 1).padStart(2, '0');
  const d = String(date.getUTCDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
}

async function updateSepPrediction(date) {
  const map = await loadSepPredictions();
  if (!map || map.size === 0) {
    predEventEl.textContent = '-';
    predIntensityEl.textContent = '-';
    return;
  }
  const tomorrow = new Date(date.getTime() + 86400000);
  const key = formatDateKey(tomorrow);
  const entry = map.get(key);
  if (!entry) {
    predEventEl.textContent = '-';
    predIntensityEl.textContent = '-';
    return;
  }
  predEventEl.textContent = entry.pEvent.toFixed(4);
  predIntensityEl.textContent = entry.intensity.toFixed(0);
}

function createCrewRow(code = '') {
  const row = document.createElement('div');
  row.className = 'crew-row';
  const input = document.createElement('input');
  input.type = 'text';
  input.inputMode = 'numeric';
  input.maxLength = 3;
  input.placeholder = 'Crew code (3 digits)';
  input.value = code;
  const remove = document.createElement('button');
  remove.type = 'button';
  remove.textContent = 'Remove';
  remove.addEventListener('click', () => row.remove());
  row.appendChild(input);
  row.appendChild(remove);
  return row;
}

function syncLogTimeInput() {
  const usingCurrent = useCurrentTime.checked;
  logDatetimeInput.disabled = usingCurrent;
  if (usingCurrent) {
    logDatetimeInput.value = datetimeInput.value;
  }
}

function openLogModal() {
  if (getCurrentRole() !== 'admin') return;
  crewListEl.innerHTML = '';
  crewListEl.appendChild(createCrewRow());
  logDatetimeInput.value = datetimeInput.value;
  useCurrentTime.checked = true;
  syncLogTimeInput();
  logModal.classList.add('open');
  logModal.setAttribute('aria-hidden', 'false');
}

function closeLogModal() {
  logModal.classList.remove('open');
  logModal.setAttribute('aria-hidden', 'true');
}

/* ============================
   NEW: Radiation overlay
   ============================ */

const API_URL = "http://54.180.8.15:8000/radiation_grid";

async function fetchRadiationGridFromEC2(dateUTC) {
  const year = dateUTC.getUTCFullYear();
  const month = dateUTC.getUTCMonth() + 1;
  const day = dateUTC.getUTCDate();

  const payload = {
    year: year,
    month: month,
    day: day,
    altitude: 30000,
    g_parameter: 0.0,
    goes_proton: 0.0,
    lat_step: 1.0,
    lon_step: 1.0
  };

  const res = await fetch(API_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });

  if (!res.ok) {
    throw new Error(`Radiation API failed: ${res.status}`);
  }

  const grid = await res.json();

  // values: Array → Float32Array로 변환 (중요)
  grid.values = new Float32Array(grid.values);

  return grid;
}




// color ramp: low=blue -> high=red (continuous)
// returns [r,g,b] 0..255
function colorForValue(v, vmin, vmax) {
  const tRaw = (v - vmin) / Math.max(1e-9, (vmax - vmin));
  const t = Math.min(1, Math.max(0, tRaw));

  // A smooth multi-stop gradient for nicer transitions:
  // 0.00: deep blue
  // 0.25: cyan
  // 0.50: greenish
  // 0.75: yellow/orange
  // 1.00: red
  const stops = [
    { t: 0.00, c: [ 42, 108, 255] },
    { t: 0.25, c: [ 55, 224, 255] },
    { t: 0.50, c: [125, 255, 141] },
    { t: 0.75, c: [255, 209, 102] },
    { t: 1.00, c: [255,  59,  59] },
  ];

  let i = 0;
  while (i < stops.length - 2 && t > stops[i + 1].t) i++;

  const s0 = stops[i];
  const s1 = stops[i + 1];
  const localT = (t - s0.t) / Math.max(1e-9, (s1.t - s0.t));

  const r = Math.round(s0.c[0] + (s1.c[0] - s0.c[0]) * localT);
  const g = Math.round(s0.c[1] + (s1.c[1] - s0.c[1]) * localT);
  const b = Math.round(s0.c[2] + (s1.c[2] - s0.c[2]) * localT);
  return [r, g, b];
}

function buildRadiationTexture(grid) {
  const { width, height, values, min, max } = grid;

  // RGBA texture
  const data = new Uint8Array(width * height * 4);

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const v = values[y * width + x];
      const [r, g, b] = colorForValue(v, min, max);

      const idx = (y * width + x) * 4;
      data[idx + 0] = r;
      data[idx + 1] = g;
      data[idx + 2] = b;

      // Alpha: keep it visible but not too aggressive.
      // Optionally make higher radiation slightly more opaque.
      const t = (v - min) / Math.max(1e-9, (max - min));
      const alpha = 70 + Math.round(120 * Math.min(1, Math.max(0, t))); // 70..190
      data[idx + 3] = alpha;
    }
  }

  const tex = new THREE.DataTexture(data, width, height, THREE.RGBAFormat);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = THREE.RepeatWrapping;
  tex.wrapT = THREE.ClampToEdgeWrapping;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.needsUpdate = true;
  return tex;
}

// Create atmosphere-like overlay sphere
const RADIATION_RADIUS = EARTH_RADIUS + 0.035;
const radiationGeometry = new THREE.SphereGeometry(RADIATION_RADIUS, 128, 128);

let radiationTexture = null;
let radiationGrid = null;
const radiationMaterial = new THREE.MeshBasicMaterial({
  map: null,
  transparent: true,
  opacity: 0.70,     // base opacity; alpha channel also applies
  depthWrite: false, // so it doesn't "cut holes" in earth
  blending: THREE.NormalBlending,
});
const radiationShell = new THREE.Mesh(radiationGeometry, radiationMaterial);
radiationShell.renderOrder = 2;
scene.add(radiationShell);

async function updateRadiationOverlay(dateUTC) {
  try {
    const grid = await fetchRadiationGridFromEC2(dateUTC);
    const tex = buildRadiationTexture(grid);

    if (radiationTexture) {
      radiationTexture.dispose();
    }

    radiationTexture = tex;
    radiationMaterial.map = radiationTexture;
    radiationMaterial.needsUpdate = true;
    radiationGrid = grid;

    legendMinEl.textContent = `${grid.min.toFixed(3)} uSv/h`;
    legendMaxEl.textContent = `${grid.max.toFixed(3)} uSv/h`;
    return grid;
  } catch (err) {
    console.error("Radiation fetch failed:", err);
    return null;
  }
}


toggleRadiation.addEventListener('change', () => {
  radiationShell.visible = toggleRadiation.checked;
});

/* ============================
   NEW: init + update hooks
   ============================ */

function setInitialDateTime() {
  const initial = new Date(Date.UTC(2000, 0, 1, 0, 0, 0));
  datetimeInput.value = formatDateTimeLocalUTC(initial);
  simulatedTime = initial;
  lastRadiationMinute = Math.floor(initial.getTime() / 60000);
  updateSunFromDate(initial);
  updateRadiationOverlay(initial);
  updateSepPrediction(initial);
}


let isTimeRunning = true;
const TIME_SCALE = 1800;
let simulatedTime = null;
let lastFrameTime = performance.now();
let lastUiUpdate = 0;
let lastRadiationMinute = null;

function formatDateTimeLocalUTC(date) {
  const pad = (n) => String(n).padStart(2, '0');
  return `${date.getUTCFullYear()}-${pad(date.getUTCMonth() + 1)}-${pad(date.getUTCDate())}T${pad(date.getUTCHours())}:${pad(date.getUTCMinutes())}:${pad(date.getUTCSeconds())}`;
}

function updateTimeFlowFrame(nowMs) {
  if (!simulatedTime) {
    simulatedTime = parseDateTimeLocalAsUTC(datetimeInput.value) || new Date();
  }
  const elapsedMs = nowMs - lastFrameTime;
  lastFrameTime = nowMs;

  if (!isTimeRunning) return;

  simulatedTime = new Date(simulatedTime.getTime() + elapsedMs * TIME_SCALE);

  updateSunFromDate(simulatedTime);

  const minuteKey = Math.floor(simulatedTime.getTime() / 60000);
  if (minuteKey !== lastRadiationMinute) {
    updateRadiationOverlay(simulatedTime);
    lastRadiationMinute = minuteKey;
  }

  if (nowMs - lastUiUpdate > 250) {
    datetimeInput.value = formatDateTimeLocalUTC(simulatedTime);
    updateSepPrediction(simulatedTime);
    if (currentRoute && radiationGrid) {
      const dose = computeRouteDose(currentRoute, radiationGrid);
      routeDistanceEl.textContent = `${dose.distanceKm.toFixed(1)} km`;
      routeTimeEl.textContent = `${dose.hours.toFixed(2)} h`;
      routeDoseEl.textContent = `${dose.doseMicroSv.toFixed(2)} uSv (${dose.doseSv.toExponential(3)} Sv)`;
    }
    lastUiUpdate = nowMs;
  }
}

toggleTimeFlow.addEventListener('click', () => {
  isTimeRunning = !isTimeRunning;
  toggleTimeFlow.textContent = isTimeRunning ? 'Pause' : 'Resume';
  lastFrameTime = performance.now();
});

function applyDateTimeSelection(date) {
  simulatedTime = date;
  lastRadiationMinute = Math.floor(date.getTime() / 60000);
  updateSunFromDate(date);
  updateRadiationOverlay(date);
  updateSepPrediction(date);
  if (currentRoute && radiationGrid) {
    const dose = computeRouteDose(currentRoute, radiationGrid);
    routeDistanceEl.textContent = `${dose.distanceKm.toFixed(1)} km`;
    routeTimeEl.textContent = `${dose.hours.toFixed(2)} h`;
    routeDoseEl.textContent = `${dose.doseMicroSv.toFixed(2)} uSv (${dose.doseSv.toExponential(3)} Sv)`;
  }
}


useCurrentTime.addEventListener('change', () => {
  syncLogTimeInput();
});

addCrewBtn.addEventListener('click', () => {
  crewListEl.appendChild(createCrewRow());
});

cancelLogBtn.addEventListener('click', () => {
  closeLogModal();
});

document.addEventListener('keydown', (event) => {
  if (event.key !== 'Escape') return;
  if (logModal.classList.contains('open')) {
    closeLogModal();
  }
});

saveLogBtn.addEventListener('click', async () => {
  if (getCurrentRole() !== 'admin') return;
  if (!currentRoute) {
    window.alert('먼저 노선을 선택하고 Show를 눌러주세요.');
    return;
  }
  const crewCodes = Array.from(crewListEl.querySelectorAll('input'))
    .map((input) => input.value.trim())
    .filter(Boolean);
  if (crewCodes.length === 0) {
    window.alert('탑승 승무원 코드를 최소 1명 입력해주세요.');
    return;
  }
  const invalidCode = crewCodes.find((code) => !/^\d{3}$/.test(code));
  if (invalidCode) {
    window.alert('Crew code는 세자리 숫자여야 합니다.');
    return;
  }
  const sourceValue = useCurrentTime.checked ? datetimeInput.value : logDatetimeInput.value;
  const dateUTC = parseDateTimeLocalAsUTC(sourceValue) || new Date();

  if (!radiationGrid) {
    await updateRadiationOverlay(dateUTC);
  }
  if (!radiationGrid) {
    window.alert('방사선 데이터를 불러오지 못했습니다. 잠시 후 다시 시도해주세요.');
    return;
  }

  const dose = computeRouteDose(currentRoute, radiationGrid);

  const entry = {
    id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    dateUTC: dateUTC.toISOString(),
    dateDisplay: sourceValue,
    depart: departSelect.value,
    arrive: arriveSelect.value,
    srcLat: currentRoute.srcLat,
    srcLon: currentRoute.srcLon,
    dstLat: currentRoute.dstLat,
    dstLon: currentRoute.dstLon,
    distanceKm: dose.distanceKm,
    hours: dose.hours,
    doseMicroSv: dose.doseMicroSv,
    doseSv: dose.doseSv,
    crewCodes,
    addedBy: getCurrentUser(),
  };

  const records = loadFlightRecords();
  records.push(entry);
  saveFlightRecords(records);
  closeLogModal();
  window.alert('Saved.');
});

document.addEventListener('keydown', (event) => {
  if (event.code !== 'Space') return;
  const target = event.target;
  if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable)) {
    return;
  }
  event.preventDefault();
  toggleTimeFlow.click();
});

datetimeInput.addEventListener('change', () => {
  const value = datetimeInput.value;
  if (!value) return;
  const date = parseDateTimeLocalAsUTC(value);
  if (date && !Number.isNaN(date.getTime())) {
    applyDateTimeSelection(date);
  }
});

setInitialDateTime();
applyRoleUI();

// DATA LOAD (unchanged)
let data;
try {
  const res = await fetch('./data/capitals_routes.json');
  if (!res.ok) {
    throw new Error(`Failed to load data: ${res.status}`);
  }
  data = await res.json();
} catch (err) {
  console.error(err);
  window.alert('데이터를 불러오지 못했습니다. 로컬 서버(http://localhost:8001)로 열어주세요.');
  throw err;
}

const allCapitals = data.capitals.slice().sort();
const capitalRoutes = new Map();
const reverseCapitalRoutes = new Map();
let currentRoute = null;

for (const route of data.routes) {
  const srcCapital = data.capitalByAirport[route.src];
  const dstCapital = data.capitalByAirport[route.dst];
  if (!srcCapital || !dstCapital) continue;

  if (!capitalRoutes.has(srcCapital)) capitalRoutes.set(srcCapital, new Set());
  if (!reverseCapitalRoutes.has(dstCapital)) reverseCapitalRoutes.set(dstCapital, new Set());
  capitalRoutes.get(srcCapital).add(dstCapital);
  reverseCapitalRoutes.get(dstCapital).add(srcCapital);
}

function rebuildSelect(select, options, selectedValue, placeholder) {
  select.innerHTML = '';
  const first = new Option(placeholder, '');
  first.selected = selectedValue === '';
  select.add(first);
  for (const name of options) {
    const opt = new Option(name, name);
    if (name === selectedValue) opt.selected = true;
    select.add(opt);
  }
}

function updateArriveOptions() {
  const depart = departSelect.value;
  const allowed = depart ? Array.from(capitalRoutes.get(depart) || []) : allCapitals;
  allowed.sort();
  const current = arriveSelect.value;
  rebuildSelect(arriveSelect, allowed, allowed.includes(current) ? current : '', 'Select');
}

function updateDepartOptions() {
  const arrive = arriveSelect.value;
  const allowed = arrive ? Array.from(reverseCapitalRoutes.get(arrive) || []) : allCapitals;
  allowed.sort();
  const current = departSelect.value;
  rebuildSelect(departSelect, allowed, allowed.includes(current) ? current : '', 'Select');
}

rebuildSelect(departSelect, allCapitals, '', 'Select');
rebuildSelect(arriveSelect, allCapitals, '', 'Select');

departSelect.addEventListener('change', () => {
  updateArriveOptions();
});

arriveSelect.addEventListener('change', () => {
  updateDepartOptions();
});

showBtn.addEventListener('click', async () => {
  const depart = departSelect.value;
  const arrive = arriveSelect.value;
  if (!depart || !arrive) {
    window.alert('depart와 arrive를 모두 선택해주세요.');
    return;
  }

  let best = null;
  let bestDist = Infinity;

  for (const route of data.routes) {
    const srcCapital = data.capitalByAirport[route.src];
    const dstCapital = data.capitalByAirport[route.dst];
    if (srcCapital !== depart || dstCapital !== arrive) continue;

    const dist = greatCircleKm(route.srcLat, route.srcLon, route.dstLat, route.dstLon);
    if (dist < bestDist) {
      bestDist = dist;
      best = route;
    }
  }

  if (!best) {
    window.alert('선택한 수도 간에 노선이 없습니다.');
    return;
  }

  drawRoute(best);
  setRouteCenteredView(best);
  currentRoute = best;
  isRouteSideView = false;
  changeViewBtn.textContent = 'Change view';
  changeViewBtn.style.display = 'inline-flex';

  const baseDistanceKm = greatCircleKm(best.srcLat, best.srcLon, best.dstLat, best.dstLon);
  const baseHours = baseDistanceKm / 900;
  routeDistanceEl.textContent = `${baseDistanceKm.toFixed(1)} km`;
  routeTimeEl.textContent = `${baseHours.toFixed(2)} h`;

  if (!radiationGrid) {
    const now = parseDateTimeLocalAsUTC(datetimeInput.value) || new Date();
    await updateRadiationOverlay(now);
  }
  if (radiationGrid) {
    const dose = computeRouteDose(best, radiationGrid);
    routeDoseEl.textContent = `${dose.doseMicroSv.toFixed(2)} uSv (${dose.doseSv.toExponential(3)} Sv)`;
  } else {
    routeDoseEl.textContent = '-';
  }
});

changeViewBtn.addEventListener('click', () => {
  if (!currentRoute) return;
  if (!isRouteSideView) {
    setRouteSideView(currentRoute);
    isRouteSideView = true;
    changeViewBtn.textContent = 'Reset view';
  } else {
    resetCameraView();
    isRouteSideView = false;
    changeViewBtn.textContent = 'Change view';
  }
});

addToLogBtn.addEventListener('click', () => {
  if (!isLoggedIn()) {
    window.alert('로그인 후 Add to log를 사용할 수 있습니다.');
    return;
  }
  if (getCurrentRole() !== 'admin') {
    window.alert('관리자만 비행 기록을 추가할 수 있습니다.');
    return;
  }
  openLogModal();
});

profileBtn.addEventListener('click', () => {
  const isOpen = profileMenu.style.display === 'flex';
  profileMenu.style.display = isOpen ? 'none' : 'flex';
});

profilePageLink.addEventListener('click', () => {
  const role = getCurrentRole();
  window.location.href = role === 'admin' ? './status.html' : './my_page.html';
});

logoutButton.addEventListener('click', () => {
  localStorage.removeItem(LOGIN_STORAGE_KEY);
  localStorage.removeItem(CURRENT_USER_KEY);
  localStorage.removeItem(CURRENT_ROLE_KEY);
  window.location.href = './index.html';
});

document.addEventListener('click', (event) => {
  if (!profileMenu.contains(event.target) && !profileBtn.contains(event.target)) {
    profileMenu.style.display = 'none';
  }
});

// LOOP
function animate() {
  requestAnimationFrame(animate);
  updateTimeFlowFrame(performance.now());
  if (!updateCameraTransition()) {
    controls.update();
  }
  sky.rotation.y = earth.rotation.y;
  renderer.render(scene, camera);
}
animate();

// RESIZE
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
