<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Earth Orbit Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
    }
  }
  </script>

  <style>
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
    canvas { display: block; }
    :root {
      --side-panel-width: 360px;
    }
    #ui {
      position: absolute;
      top: 16px;
      right: 28px;
      background: transparent;
      color: #ffffff;
      padding: 0;
      border-radius: 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 14px;
      display: grid;
      gap: 8px;
      z-index: 10;
      backdrop-filter: none;
      width: var(--side-panel-width);
      box-sizing: border-box;
    }
    #ui .row {
      display: flex;
      align-items: flex-end;
      gap: 8px;
    }
    #flight-select {
      display: grid;
      gap: 6px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.04);
    }
    #flight-select .section-title {
      font-size: 14px;
      font-weight: 600;
      opacity: 0.95;
    }
    #ui .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    #ui .field label {
      font-size: 12px;
      opacity: 0.8;
    }
    #ui .label-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
      vertical-align: middle;
    }
    #ui .label-dot.green { background: #00ff7f; }
    #ui .label-dot.red { background: #ff5555; }
    #brand {
      position: absolute;
      top: 12px;
      left: 16px;
      font-family: 'Arial Black', 'Impact', system-ui, sans-serif;
      font-size: 20px;
      font-weight: 800;
      letter-spacing: 2px;
      color: #ffffff;
      text-decoration: none;
      z-index: 12;
    }
    #brand:hover {
      opacity: 0.85;
    }
    #time-ui {
      position: absolute;
      bottom: 16px;
      right: 16px;
      background: rgba(0, 0, 0, 0.6);
      color: #ffffff;
      padding: 10px 12px;
      border-radius: 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 14px;
      display: grid;
      gap: 6px;
      z-index: 10;
      backdrop-filter: blur(6px);
      width: var(--side-panel-width);
      box-sizing: border-box;
    }
    #time-ui .time-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #toggleTimeFlow {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
      cursor: pointer;
      white-space: nowrap;
    }
    #time-ui label {
      font-size: 12px;
      opacity: 0.8;
    }
    #time-ui input {
      font-size: 14px;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
    }
    #time-ui input::-webkit-calendar-picker-indicator {
      filter: invert(1);
    }
    #time-ui .pred-section {
      display: grid;
      gap: 4px;
      margin-bottom: 6px;
      padding: 4px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      background: #7b10100a;
      box-sizing: border-box;
      width: 100%;
    }
    #time-ui .alara-section {
      display: none;
      gap: 6px;
      margin-bottom: 6px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.04);
      box-sizing: border-box;
      width: 100%;
    }
    #time-ui .alara-section.active {
      display: grid;
    }
    #time-ui .alara-title {
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 0.4px;
      opacity: 0.95;
    }
    #time-ui .alara-content {
      display: grid;
      gap: 6px;
      font-size: 12px;
    }
    #time-ui .alara-table {
      display: grid;
      gap: 6px;
    }
    #time-ui .alara-row {
      display: grid;
      grid-template-columns: 1fr auto auto;
      align-items: center;
      gap: 10px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.15);
      color: rgba(255,255,255,0.92);
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    #time-ui .alara-row.header {
      background: rgba(255,255,255,0.06);
      border-color: rgba(255,255,255,0.1);
      font-weight: 700;
      cursor: default;
    }
    #time-ui .alara-row.selectable {
      cursor: pointer;
    }
    #time-ui .alara-row.selected {
      border-color: rgba(255,209,102,0.9);
      background: rgba(255,209,102,0.18);
    }
    #time-ui .alara-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    #time-ui .alara-actions button {
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.08);
      color: #fff;
      font-size: 12px;
      cursor: pointer;
    }
    #time-ui .alara-actions button.primary {
      border-color: #ff6b6b;
      background: #ff6b6b;
      color: #000;
      font-weight: 700;
    }
    #time-ui .alara-selected {
      font-size: 12px;
      font-weight: 700;
      color: #7dffb0;
    }
    #time-ui .pred-title {
      font-size: 14px;
      font-weight: 600;
      opacity: 0.95;
    }
    #time-ui .pred-value {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 72px;
      height: 72px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(0,0,0,0.2);
      font-size: 14px;
    }
    #time-ui .pred-value.safe {
      background: rgba(0, 255, 127, 0.2);
      border-color: rgba(0, 255, 127, 0.7);
      color: #eafff6;
    }
    #time-ui .pred-value.warn {
      background: rgba(255, 209, 102, 0.25);
      border-color: rgba(255, 209, 102, 0.9);
      color: #fff6d6;
    }
    #time-ui .pred-value.danger {
      background: rgba(255, 59, 59, 0.25);
      border-color: rgba(255, 59, 59, 0.9);
      color: #ffe0e0;
    }
    #time-ui .pred-table {
      width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
      font-size: 13px;
      opacity: 0.9;
    }
    #time-ui .pred-table th {
      font-weight: 600;
    }
    #time-ui .pred-table th,
    #time-ui .pred-table td {
      padding: 6px;
      text-align: center;
    }
    #time-ui .pred-danger {
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.5px;
      min-width: 60px;
      text-align: center;
    }
    #time-ui .pred-danger.safe { color: #7dffb0; }
    #time-ui .pred-danger.warn { color: #ffd166; }
    #time-ui .pred-danger.danger { color: #ff7a7a; }
    #radiation-panel {
      position: absolute;
      bottom: 16px;
      left: 16px;
      background: rgba(0, 0, 0, 0.6);
      color: #ffffff;
      padding: 12px 14px;
      border-radius: 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 14px;
      display: grid;
      gap: 8px;
      z-index: 10;
      backdrop-filter: blur(6px);
      min-width: 240px;
    }
    #ui select, #ui button {
      font-size: 14px;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
    }
    #ui button {
      cursor: pointer;
      border-color: #2aa3ff;
      background: #2aa3ff;
      color: #000;
      font-weight: 600;
    }
    #ui .arrow {
      opacity: 0.7;
    }
    #profile {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      margin-bottom: 4px;
    }
    #profile button {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.1);
      color: #fff;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #profile button.admin {
      background: #000;
      color: #fff;
      font-weight: 700;
      border-color: #000;
    }
    #profile-menu {
      position: absolute;
      top: 56px;
      right: 16px;
      background: #000000;
      color: #fff;
      border-radius: 10px;
      padding: 8px;
      display: none;
      flex-direction: column;
      gap: 6px;
      border: 1px solid rgba(255,255,255,0.15);
      z-index: 11;
      min-width: 140px;
    }
    #profile-menu button {
      background: transparent;
      color: #fff;
      border: none;
      text-align: left;
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
    }
    #profile-menu .menu-link {
      background: transparent;
      color: #fff;
      text-decoration: none;
      text-align: left;
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
      display: block;
    }
    #profile-menu button:hover {
      background: rgba(255,255,255,0.12);
    }
    #profile-menu .menu-link:hover {
      background: rgba(255,255,255,0.12);
    }

    #log-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
      backdrop-filter: blur(4px);
    }
    #log-modal.open {
      display: flex;
    }
    #loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.45);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      pointer-events: all;
    }
    #loading-overlay.active {
      display: flex;
    }
    .spinner {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 4px solid rgba(255,255,255,0.2);
      border-top-color: #ffffff;
      animation: spin 0.9s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .modal-card {
      width: min(420px, 90vw);
      background: #0b0b0b;
      color: #fff;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.15);
      padding: 16px;
      display: grid;
      gap: 12px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.4);
    }
    .modal-title {
      font-size: 16px;
      font-weight: 700;
    }
    .modal-section {
      display: grid;
      gap: 8px;
    }
    .modal-subtitle {
      font-size: 13px;
      font-weight: 600;
      opacity: 0.95;
    }
    .modal-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      opacity: 0.9;
    }
    .modal-field {
      display: grid;
      gap: 6px;
      font-size: 12px;
    }
    .modal-field input {
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
      font-size: 13px;
    }
    #crew-list {
      display: grid;
      gap: 6px;
    }
    .crew-row {
      display: flex;
      gap: 6px;
    }
    .crew-row input {
      flex: 1;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
      font-size: 13px;
    }
    .crew-row button {
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.3);
      background: transparent;
      color: #fff;
      cursor: pointer;
    }
    #add-crew {
      align-self: flex-start;
      padding: 4px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.3);
      background: transparent;
      color: #fff;
      cursor: pointer;
      font-size: 12px;
    }
    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    .modal-actions button {
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid #2aa3ff;
      background: #2aa3ff;
      color: #000;
      font-weight: 600;
      cursor: pointer;
    }
    .modal-actions button.secondary {
      border-color: rgba(255,255,255,0.3);
      background: transparent;
      color: #fff;
    }

    /* === NEW: Radiation legend === */
    #legend {
      display: grid;
      gap: 6px;
    }
    #legend .title {
      font-size: 14px;
      font-weight: 600;
      opacity: 0.95;
    }
    #legend .bar {
      width: 100%;
      height: 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.22);
      background: linear-gradient(90deg, #2a6cff 0%, #37e0ff 25%, #7dff8d 50%, #ffd166 75%, #ff3b3b 100%);
    }
    #legend .labels {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      opacity: 0.85;
    }
    #route-info {
      margin-top: 8px;
      display: grid;
      gap: 4px;
      font-size: 12px;
      opacity: 0.9;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.04);
    }
    #route-info .section-title {
      font-size: 14px;
      font-weight: 600;
      opacity: 0.95;
      margin-bottom: 2px;
    }
    #route-info .row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
    #route-info .button-row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
      flex-wrap: wrap;
    }
    #route-info button {
      font-size: 14px;
      padding: 6px 14px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.1);
      color: #fff;
      cursor: pointer;
    }
  </style>
</head>
<body>
<a id="brand" href="./index.html">DDCAS</a>
<div id="time-ui">
  <div id="alara-section" class="alara-section">
    <div class="alara-title">ALARA Re-routing</div>
    <div id="alara-content" class="alara-content"></div>
  </div>
  <div class="pred-section">
    <div class="pred-title">Tomorrow's Danger Prediction</div>
    <table class="pred-table">
      <thead>
        <tr><th>Probability</th><th>Intensity</th><th></th></tr>
      </thead>
      <tbody>
        <tr>
          <td><span id="predEvent" class="pred-value">-</span></td>
          <td><span id="predIntensity" class="pred-value">-</span></td>
          <td><span id="predDanger" class="pred-danger"></span></td>
        </tr>
      </tbody>
    </table>
  </div>
  <label for="datetimeInput">Date & Time (GST)</label>
  <div class="time-row">
    <input id="datetimeInput" type="datetime-local" lang="en" step="1" />
    <button id="toggleTimeFlow" type="button">Pause</button>
  </div>
</div>
<div id="ui">
  <div id="profile">
    <button id="profileBtn" aria-label="Profile">J</button>
  </div>
  <div id="profile-menu">
    <button id="profile-page-link" class="menu-link" type="button">My Page</button>
    <button id="logout-button" type="button">Logout</button>
  </div>
  <div id="flight-select">
    <div class="section-title">Flight select</div>
    <div class="row">
      <div class="field">
        <label for="departSelect"><span class="label-dot green"></span>Depart</label>
        <select id="departSelect">
          <option value="">Select</option>
        </select>
      </div>
      <span class="arrow">→</span>
      <div class="field">
        <label for="arriveSelect"><span class="label-dot red"></span>Arrive</label>
        <select id="arriveSelect">
          <option value="">Select</option>
        </select>
      </div>
      <button id="showBtn">Show</button>
    </div>
  </div>
  <div id="route-info">
    <div class="section-title">Flight Information</div>
    <div class="row"><span>Average speed</span><span id="routeSpeed">900 km/h</span></div>
    <div class="row"><span>Distance</span><span id="routeDistance">-</span></div>
    <div class="row"><span>Flight time</span><span id="routeTime">-</span></div>
    <div class="row"><span>Total dose</span><span id="routeDose">-</span></div>
    <div class="button-row">
      <button id="addToLogBtn">Add to log</button>
      <button id="changeViewBtn" style="display:none;">Change view</button>
    </div>
  </div>

</div>

<div id="radiation-panel">
  <div id="legend">
    <div class="title">Radiation overlay</div>
    <div class="bar" aria-label="radiation color legend"></div>
    <div class="labels">
      <span id="legendMin">min</span>
      <span id="legendMax">max</span>
    </div>
    <div class="row" style="display:flex; align-items:center; gap:6px;">
      <label style="display:flex; align-items:center; gap:6px;">
        <input type="checkbox" id="toggleRadiation" checked />
        Radiation overlay
      </label>
    </div>
  </div>
</div>

<div id="log-modal" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-title">Add Flight Log</div>
    <div class="modal-section">
      <label class="modal-row">
        <input id="useCurrentTime" type="checkbox" checked />
        Use current time
      </label>
      <label class="modal-field">
        <span>Date & Time (GST)</span>
        <input id="logDatetimeInput" type="datetime-local" step="1" />
      </label>
    </div>
    <div class="modal-section">
      <div class="modal-subtitle">Crew codes</div>
      <div id="crew-list"></div>
      <button id="add-crew" type="button">+ Add crew</button>
    </div>
    <div class="modal-actions">
      <button id="save-log" type="button">Save</button>
      <button id="cancel-log" type="button" class="secondary">Cancel</button>
    </div>
  </div>
</div>

<div id="loading-overlay" aria-hidden="true">
  <div class="spinner" aria-label="Loading"></div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// SCENE
const scene = new THREE.Scene();

// CAMERA
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 4);

// RENDERER
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.NoToneMapping;
document.body.appendChild(renderer.domElement);

// CONTROLS
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.enablePan = false;
controls.minDistance = 0.6;
controls.maxDistance = 8;
controls.target.set(0, 0, 0);
controls.update();
const defaultCameraState = {
  position: camera.position.clone(),
  target: controls.target.clone(),
};
let cameraTransition = null;

function startCameraTransition(position, target, up, durationMs = 800) {
  cameraTransition = {
    startTime: performance.now(),
    durationMs,
    startPosition: camera.position.clone(),
    startTarget: controls.target.clone(),
    startUp: camera.up.clone(),
    endPosition: position.clone(),
    endTarget: target.clone(),
    endUp: up.clone(),
  };
}

function updateCameraTransition() {
  if (!cameraTransition) return false;
  const now = performance.now();
  const elapsed = now - cameraTransition.startTime;
  const t = Math.min(1, elapsed / cameraTransition.durationMs);
  const eased = 0.5 - 0.5 * Math.cos(Math.PI * t);

  camera.position.lerpVectors(
    cameraTransition.startPosition,
    cameraTransition.endPosition,
    eased
  );
  controls.target.lerpVectors(
    cameraTransition.startTarget,
    cameraTransition.endTarget,
    eased
  );
  camera.up
    .lerpVectors(cameraTransition.startUp, cameraTransition.endUp, eased)
    .normalize();
  controls.update();

  if (t >= 1) {
    cameraTransition = null;
  }
  return true;
}

// BACKGROUND (sky sphere that rotates with earth)
const textureLoader = new THREE.TextureLoader();
const SKY_RADIUS = 50;
const skyTexture = textureLoader.load('./texture/8k_stars_milky_way.jpg');
skyTexture.colorSpace = THREE.SRGBColorSpace;
const sky = new THREE.Mesh(
  new THREE.SphereGeometry(SKY_RADIUS, 64, 64),
  new THREE.MeshBasicMaterial({ map: skyTexture, side: THREE.BackSide, depthWrite: false })
);
scene.add(sky);

const sunTexture = textureLoader.load('./texture/ssun.png');
sunTexture.colorSpace = THREE.SRGBColorSpace;
const sunSprite = new THREE.Sprite(
  new THREE.SpriteMaterial({
    map: sunTexture,
    color: 0xffffff,
    transparent: true,
    depthWrite: false,
  })
);
sunSprite.scale.set(SKY_RADIUS * 0.12, SKY_RADIUS * 0.12, 1);
scene.add(sunSprite);

// LIGHTS
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const sunLight = new THREE.DirectionalLight(0xffffff, 1);
scene.add(sunLight);

// EARTH
const EARTH_RADIUS = 1;
const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
const earthTexture = textureLoader.load('./texture/8k_earth_daymap.jpg');
earthTexture.colorSpace = THREE.SRGBColorSpace;

const earth = new THREE.Mesh(
  earthGeometry,
  new THREE.MeshStandardMaterial({ map: earthTexture })
);
scene.add(earth);

// MARKER
function latLonToVector3(lat, lon, radius) {
  const u = (lon + 180) / 360;
  const v = (90 - lat) / 180;

  const theta = v * Math.PI;
  const phi = u * Math.PI * 2;

  const sinTheta = Math.sin(theta);
  const x = -radius * Math.cos(phi) * sinTheta;
  const y =  radius * Math.cos(theta);
  const z =  radius * Math.sin(phi) * sinTheta;

  return new THREE.Vector3(x, y, z);
}

function latLonToUnitVector(lat, lon) {
  return latLonToVector3(lat, lon, 1).normalize();
}

function getSolarDeclination(dayOfYear) {
  return 23.44 * Math.sin(((2 * Math.PI) / 365) * (dayOfYear - 81));
}

function dayOfYearUTC(date) {
  const start = Date.UTC(date.getUTCFullYear(), 0, 0);
  const now = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
  return Math.floor((now - start) / 86400000);
}

function updateSunFromDate(date) {
  const doy = dayOfYearUTC(date);
  const declination = getSolarDeclination(doy);

  const hours =
    date.getUTCHours() +
    date.getUTCMinutes() / 60 +
    date.getUTCSeconds() / 3600;
  const subsolarLon = 180 - (hours * 15);

  const sunDir = latLonToUnitVector(declination, subsolarLon);
  sunLight.position.copy(sunDir.clone().multiplyScalar(5));
  sunSprite.position.copy(sunDir.clone().multiplyScalar(SKY_RADIUS - 1));
  sunLight.target.position.set(0, 0, 0);
  sunLight.target.updateMatrixWorld();
}

const startMarker = new THREE.Mesh(
  new THREE.SphereGeometry(0.015, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0x00ff7f })
);
const endMarker = new THREE.Mesh(
  new THREE.SphereGeometry(0.015, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0xff5555 })
);
startMarker.visible = false;
endMarker.visible = false;
scene.add(startMarker);
scene.add(endMarker);

let currentRouteLine = null;

function greatCircleKm(lat1, lon1, lat2, lon2) {
  const r = 6371.0088;
  const toRad = (v) => (v * Math.PI) / 180;
  const phi1 = toRad(lat1);
  const phi2 = toRad(lat2);
  const dPhi = toRad(lat2 - lat1);
  const dLambda = toRad(lon2 - lon1);
  const a = Math.sin(dPhi / 2) ** 2 +
    Math.cos(phi1) * Math.cos(phi2) * Math.sin(dLambda / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return r * c;
}

function buildArcPoints(lat1, lon1, lat2, lon2, segments = 64) {
  const start = latLonToVector3(lat1, lon1, 1).normalize();
  const end = latLonToVector3(lat2, lon2, 1).normalize();
  const dot = Math.min(1, Math.max(-1, start.dot(end)));
  const omega = Math.acos(dot);
  const sinOmega = Math.sin(omega);
  const points = [];
  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    let p;
    if (sinOmega < 1e-6) {
      p = start.clone().lerp(end, t).normalize();
    } else {
      const a = Math.sin((1 - t) * omega) / sinOmega;
      const b = Math.sin(t * omega) / sinOmega;
      p = start.clone().multiplyScalar(a).add(end.clone().multiplyScalar(b)).normalize();
    }
    p.multiplyScalar(EARTH_RADIUS + 0.02);
    points.push(p);
  }
  return points;
}

function buildArcPointsFromVectors(startVec, endVec, segments = 64) {
  const start = startVec.clone().normalize();
  const end = endVec.clone().normalize();
  const dot = Math.min(1, Math.max(-1, start.dot(end)));
  const omega = Math.acos(dot);
  const sinOmega = Math.sin(omega);
  const points = [];
  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    let p;
    if (sinOmega < 1e-6) {
      p = start.clone().lerp(end, t).normalize();
    } else {
      const a = Math.sin((1 - t) * omega) / sinOmega;
      const b = Math.sin(t * omega) / sinOmega;
      p = start.clone().multiplyScalar(a).add(end.clone().multiplyScalar(b)).normalize();
    }
    p.multiplyScalar(EARTH_RADIUS + 0.02);
    points.push(p);
  }
  return points;
}

function computeAlternativeDose(route, alt, grid) {
  const doseAB = computeRouteDose({
    srcLat: route.srcLat,
    srcLon: route.srcLon,
    dstLat: alt.mid.lat,
    dstLon: alt.mid.lon,
  }, grid);
  const doseBC = computeRouteDose({
    srcLat: alt.mid.lat,
    srcLon: alt.mid.lon,
    dstLat: route.dstLat,
    dstLon: route.dstLon,
  }, grid);
  const distanceKm = typeof alt.distanceKm === 'number'
    ? alt.distanceKm
    : doseAB.distanceKm + doseBC.distanceKm;
  return {
    distanceKm,
    hours: distanceKm / 900,
    doseMicroSv: doseAB.doseMicroSv + doseBC.doseMicroSv,
    doseSv: doseAB.doseSv + doseBC.doseSv,
  };
}

function vectorToLatLon(v) {
  const lat = 90 - Math.acos(v.y) * 180 / Math.PI;
  const lon = Math.atan2(v.z, -v.x) * 180 / Math.PI;
  return { lat, lon };
}

function sampleRadiationAt(grid, lat, lon) {
  if (!grid) return null;
  const { width, height, latStep, lonStep, values } = grid;
  let wrappedLon = lon;
  if (wrappedLon < -180) wrappedLon += 360;
  if (wrappedLon >= 180) wrappedLon -= 360;
  const x = Math.min(width - 1, Math.max(0, Math.floor((wrappedLon + 180) / lonStep)));
  const y = Math.min(height - 1, Math.max(0, Math.floor((90 - lat) / latStep)));
  return values[y * width + x];
}

function computeRouteDose(route, grid) {
  const distanceKm = greatCircleKm(route.srcLat, route.srcLon, route.dstLat, route.dstLon);
  const hours = distanceKm / 900;
  const segments = Math.max(64, Math.ceil(distanceKm / 200));

  const start = latLonToVector3(route.srcLat, route.srcLon, 1).normalize();
  const end = latLonToVector3(route.dstLat, route.dstLon, 1).normalize();
  const dot = Math.min(1, Math.max(-1, start.dot(end)));
  const omega = Math.acos(dot);
  const sinOmega = Math.sin(omega);

  let totalMicroSv = 0;
  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    let p;
    if (sinOmega < 1e-6) {
      p = start.clone().lerp(end, t).normalize();
    } else {
      const a = Math.sin((1 - t) * omega) / sinOmega;
      const b = Math.sin(t * omega) / sinOmega;
      p = start.clone().multiplyScalar(a).add(end.clone().multiplyScalar(b)).normalize();
    }
    const { lat, lon } = vectorToLatLon(p);
    const rate = sampleRadiationAt(grid, lat, lon);
    if (rate != null) {
      totalMicroSv += rate;
    }
  }

  const avgRate = totalMicroSv / (segments + 1);
  const doseMicroSv = avgRate * hours;
  const doseSv = doseMicroSv * 1e-6;

  return { distanceKm, hours, doseMicroSv, doseSv };
}

function drawRoute(route) {
  if (currentRouteLine) {
    scene.remove(currentRouteLine);
    currentRouteLine.geometry.dispose();
    currentRouteLine.material.dispose();
    currentRouteLine = null;
  }

  const points = buildArcPoints(route.srcLat, route.srcLon, route.dstLat, route.dstLon);
  const routeGeometry = new THREE.BufferGeometry().setFromPoints(points);
  const routeMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
  currentRouteLine = new THREE.Line(routeGeometry, routeMaterial);
  scene.add(currentRouteLine);

  startMarker.position.copy(latLonToVector3(route.srcLat, route.srcLon, EARTH_RADIUS + 0.02));
  endMarker.position.copy(latLonToVector3(route.dstLat, route.dstLon, EARTH_RADIUS + 0.02));
  startMarker.visible = true;
  endMarker.visible = true;
}

function setRouteCenteredView(route) {
  const start = latLonToVector3(route.srcLat, route.srcLon, EARTH_RADIUS);
  const end = latLonToVector3(route.dstLat, route.dstLon, EARTH_RADIUS);
  let midUnit = start.clone().normalize().add(end.clone().normalize());
  if (midUnit.lengthSq() < 1e-6) {
    midUnit = start.clone().normalize();
  }
  midUnit.normalize();

  const target = midUnit.clone().multiplyScalar(EARTH_RADIUS);
  let radius = 0;
  for (const p of [start, end]) {
    radius = Math.max(radius, target.distanceTo(p));
  }

  const verticalFov = THREE.MathUtils.degToRad(camera.fov);
  const horizontalFov = 2 * Math.atan(Math.tan(verticalFov / 2) * camera.aspect);
  const minFov = Math.min(verticalFov, horizontalFov);
  const distance = Math.max(EARTH_RADIUS * 1.6, (radius * 1.9) / Math.tan(minFov / 2));

  const desiredPosition = midUnit.multiplyScalar(distance);
  const desiredTarget = new THREE.Vector3(0, 0, 0);
  const desiredUp = new THREE.Vector3(0, 1, 0);
  startCameraTransition(desiredPosition, desiredTarget, desiredUp, 900);
}

function resetCameraView() {
  if (currentRoute) {
    setRouteCenteredView(currentRoute);
    return;
  }
  startCameraTransition(
    defaultCameraState.position.clone(),
    defaultCameraState.target.clone(),
    new THREE.Vector3(0, 1, 0),
    900
  );
}

function setRouteSideView(route) {
  const start = latLonToVector3(route.srcLat, route.srcLon, EARTH_RADIUS);
  const end = latLonToVector3(route.dstLat, route.dstLon, EARTH_RADIUS);
  const startUnit = start.clone().normalize();
  const endUnit = end.clone().normalize();

  let midUnit = startUnit.clone().add(endUnit);
  if (midUnit.lengthSq() < 1e-6) {
    midUnit = startUnit.clone();
  }
  midUnit.normalize();

  let planeNormal = startUnit.clone().cross(endUnit);
  if (planeNormal.lengthSq() < 1e-6) {
    planeNormal = new THREE.Vector3(0, 1, 0).cross(midUnit);
  }
  planeNormal.normalize();

  const tiltRad = THREE.MathUtils.degToRad(28);
  const viewDir = planeNormal.clone()
    .multiplyScalar(Math.cos(tiltRad))
    .add(midUnit.clone().multiplyScalar(Math.sin(tiltRad)))
    .normalize();
  const targetOffset = 0.0;
  const target = midUnit.clone().multiplyScalar(EARTH_RADIUS + targetOffset);

  let radius = 0;
  for (const p of [start, end]) {
    radius = Math.max(radius, target.distanceTo(p));
  }

  const verticalFov = THREE.MathUtils.degToRad(camera.fov);
  const horizontalFov = 2 * Math.atan(Math.tan(verticalFov / 2) * camera.aspect);
  const baseDistance = Math.max(
    EARTH_RADIUS * 1.0,
    (radius * 1.0) / Math.tan(horizontalFov / 2)
  );
  const distance = baseDistance * 0.45;

  const desiredPosition = target.clone().add(viewDir.multiplyScalar(distance));
  const desiredTarget = target.clone();
  const desiredUp = midUnit.clone();
  startCameraTransition(desiredPosition, desiredTarget, desiredUp, 900);
}

// UI + DATA
const departSelect = document.getElementById('departSelect');
const arriveSelect = document.getElementById('arriveSelect');
const showBtn = document.getElementById('showBtn');
const datetimeInput = document.getElementById('datetimeInput');
const toggleTimeFlow = document.getElementById('toggleTimeFlow');
const profileBtn = document.getElementById('profileBtn');
const profileMenu = document.getElementById('profile-menu');
const FLIGHT_RECORDS_KEY = 'ddcas_flight_records';
const LOGIN_STORAGE_KEY = 'ddcas_logged_in';
const CURRENT_USER_KEY = 'ddcas_current_user';
const CURRENT_ROLE_KEY = 'ddcas_current_role';
const CURRENT_CREW_CODE_KEY = 'ddcas_current_crew_code';
const logoutButton = document.getElementById('logout-button');
const profilePageLink = document.getElementById('profile-page-link');
const predEventEl = document.getElementById('predEvent');
const predIntensityEl = document.getElementById('predIntensity');
const predDangerEl = document.getElementById('predDanger');
const alaraSection = document.getElementById('alara-section');
const alaraContent = document.getElementById('alara-content');

// NEW: legend elements
const legendMinEl = document.getElementById('legendMin');
const legendMaxEl = document.getElementById('legendMax');
const routeDistanceEl = document.getElementById('routeDistance');
const routeTimeEl = document.getElementById('routeTime');
const routeDoseEl = document.getElementById('routeDose');
const addToLogBtn = document.getElementById('addToLogBtn');
const changeViewBtn = document.getElementById('changeViewBtn');
const toggleRadiation = document.getElementById('toggleRadiation');
let isRouteSideView = false;

const logModal = document.getElementById('log-modal');
const useCurrentTime = document.getElementById('useCurrentTime');
const logDatetimeInput = document.getElementById('logDatetimeInput');
const crewListEl = document.getElementById('crew-list');
const addCrewBtn = document.getElementById('add-crew');
const saveLogBtn = document.getElementById('save-log');
const cancelLogBtn = document.getElementById('cancel-log');
const loadingOverlay = document.getElementById('loading-overlay');
let loadingCount = 0;

function getCurrentUser() {
  return localStorage.getItem(CURRENT_USER_KEY) || 'guest';
}

function isLoggedIn() {
  return localStorage.getItem(LOGIN_STORAGE_KEY) === 'true' &&
    Boolean(localStorage.getItem(CURRENT_USER_KEY));
}

function getCurrentRole() {
  return localStorage.getItem(CURRENT_ROLE_KEY) || 'crew';
}

function applyRoleUI() {
  const role = getCurrentRole();
  addToLogBtn.style.display = isLoggedIn() && role === 'admin' ? 'inline-flex' : 'none';
  profilePageLink.textContent = role === 'admin' ? 'Status' : 'My Page';
  profileBtn.textContent = role === 'admin' ? 'A' : 'J';
  profileBtn.classList.toggle('admin', role === 'admin');
}

function loadFlightRecords() {
  try {
    const raw = localStorage.getItem(FLIGHT_RECORDS_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : [];
  } catch (err) {
    console.warn('Failed to read flight records', err);
    return [];
  }
}

function saveFlightRecords(records) {
  localStorage.setItem(FLIGHT_RECORDS_KEY, JSON.stringify(records));
}

function parseDateTimeLocalAsUTC(value) {
  const match = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(?::(\d{2}))?$/.exec(value);
  if (!match) return null;
  const [, y, m, d, hh, mm, ss] = match;
  return new Date(Date.UTC(
    Number(y),
    Number(m) - 1,
    Number(d),
    Number(hh),
    Number(mm),
    Number(ss || 0)
  ));
}

let sepPredictionMap = null;
let latestPrediction = null;
let alaraAltLine = null;
let alaraMidLine = null;
let alaraMidMarker = null;
let alaraPerpLine = null;
let alaraBMarker = null;
let alaraAltRoute = null;
let alaraSelection = null;

async function loadSepPredictions() {
  if (sepPredictionMap) return sepPredictionMap;
  const map = new Map();
  try {
    const res = await fetch('./forecast_sep/sep_pred_data/pred_2000.csv');
    if (!res.ok) throw new Error(`SEP csv load failed: ${res.status}`);
    const text = await res.text();
    const lines = text.trim().split('\n');
    lines.shift();
    for (const line of lines) {
      const [date, pEvent, intensity, expectedSep] = line.split(',');
      if (!date) continue;
      map.set(date.trim(), {
        pEvent: Number(pEvent),
        intensity: Number(intensity),
        expectedSep: Number(expectedSep),
      });
    }
  } catch (err) {
    console.warn('Failed to load SEP predictions', err);
  }
  sepPredictionMap = map;
  return map;
}

function formatDateKey(date) {
  const y = date.getUTCFullYear();
  const m = String(date.getUTCMonth() + 1).padStart(2, '0');
  const d = String(date.getUTCDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
}

async function updateSepPrediction(date) {
  const map = await loadSepPredictions();
  if (!map || map.size === 0) {
    predEventEl.textContent = '-';
    predIntensityEl.textContent = '-';
    predEventEl.classList.remove('safe', 'warn', 'danger');
    predIntensityEl.classList.remove('safe', 'warn', 'danger');
    predDangerEl.textContent = '';
    predDangerEl.classList.remove('safe', 'warn', 'danger');
    latestPrediction = null;
    updateAlaraUI();
    return;
  }
  const key = formatDateKey(date);
  const entry = map.get(key);
  if (!entry) {
    predEventEl.textContent = '-';
    predIntensityEl.textContent = '-';
    predEventEl.classList.remove('safe', 'warn', 'danger');
    predIntensityEl.classList.remove('safe', 'warn', 'danger');
    predDangerEl.textContent = '';
    predDangerEl.classList.remove('safe', 'warn', 'danger');
    latestPrediction = null;
    updateAlaraUI();
    return;
  }
  predEventEl.textContent = entry.pEvent.toFixed(4);
  predIntensityEl.textContent = entry.intensity.toFixed(0);

  predEventEl.classList.remove('safe', 'warn', 'danger');
  predIntensityEl.classList.remove('safe', 'warn', 'danger');
  let level = 'danger';
  if (entry.pEvent <= 0.3) {
    level = 'safe';
  } else if (entry.pEvent < 0.6) {
    level = 'warn';
  }
  predEventEl.classList.add(level);
  predDangerEl.classList.remove('safe', 'warn', 'danger');
  predDangerEl.classList.add(level);
  if (level === 'safe') {
    predDangerEl.textContent = 'SAFE';
  } else if (level === 'warn') {
    predDangerEl.textContent = 'CAUTION';
  } else {
    predDangerEl.textContent = 'WARNING';
  }
  latestPrediction = { pEvent: entry.pEvent, intensity: entry.intensity, level };
  updateAlaraUI();
}

function slerpUnit(start, end, t) {
  const dot = Math.min(1, Math.max(-1, start.dot(end)));
  const omega = Math.acos(dot);
  const sinOmega = Math.sin(omega);
  if (sinOmega < 1e-6) {
    return start.clone().lerp(end, t).normalize();
  }
  const a = Math.sin((1 - t) * omega) / sinOmega;
  const b = Math.sin(t * omega) / sinOmega;
  return start.clone().multiplyScalar(a).add(end.clone().multiplyScalar(b)).normalize();
}

function greatCircleKmFromVectors(a, b) {
  const dot = Math.min(1, Math.max(-1, a.dot(b)));
  const omega = Math.acos(dot);
  return 6371.0088 * omega;
}

function buildTwoLegPoints(aLat, aLon, bLat, bLon, cLat, cLon) {
  const first = buildArcPoints(aLat, aLon, bLat, bLon);
  const second = buildArcPoints(bLat, bLon, cLat, cLon);
  return first.concat(second.slice(1));
}

function clearAlaraAltLine() {
  if (alaraAltLine) {
    scene.remove(alaraAltLine);
    alaraAltLine.traverse((obj) => {
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) obj.material.dispose();
    });
    alaraAltLine = null;
  }
  if (alaraMidLine) {
    scene.remove(alaraMidLine);
    alaraMidLine.geometry.dispose();
    alaraMidLine.material.dispose();
    alaraMidLine = null;
  }
  if (alaraMidMarker) {
    scene.remove(alaraMidMarker);
    alaraMidMarker.geometry.dispose();
    alaraMidMarker.material.dispose();
    alaraMidMarker = null;
  }
  if (alaraPerpLine) {
    scene.remove(alaraPerpLine);
    alaraPerpLine.geometry.dispose();
    alaraPerpLine.material.dispose();
    alaraPerpLine = null;
  }
  if (alaraBMarker) {
    scene.remove(alaraBMarker);
    alaraBMarker.geometry.dispose();
    alaraBMarker.material.dispose();
    alaraBMarker = null;
  }
}

function renderAlaraAltLine(route, midPoint, axisPerpVec, midVec) {
  clearAlaraAltLine();
  const group = new THREE.Group();
  const material = new THREE.LineBasicMaterial({
    color: 0xffd166,
    transparent: true,
    opacity: 1,
    depthTest: false,
  });
  let pointsAB;
  let pointsBC;
  if (midVec) {
    const startVec = latLonToVector3(route.srcLat, route.srcLon, 1);
    const endVec = latLonToVector3(route.dstLat, route.dstLon, 1);
    pointsAB = buildArcPointsFromVectors(startVec, midVec);
    pointsBC = buildArcPointsFromVectors(midVec, endVec);
  } else {
    pointsAB = buildArcPoints(route.srcLat, route.srcLon, midPoint.lat, midPoint.lon);
    pointsBC = buildArcPoints(midPoint.lat, midPoint.lon, route.dstLat, route.dstLon);
  }
  const lineAB = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsAB), material);
  const lineBC = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsBC), material);
  lineAB.renderOrder = 10;
  lineBC.renderOrder = 10;
  group.add(lineAB);
  group.add(lineBC);
  alaraAltLine = group;
  scene.add(alaraAltLine);

  const start = latLonToVector3(route.srcLat, route.srcLon, EARTH_RADIUS).normalize();
  const end = latLonToVector3(route.dstLat, route.dstLon, EARTH_RADIUS).normalize();
  const dUnit = slerpUnit(start, end, 0.5);
  const axisPerp = axisPerpVec ? axisPerpVec.clone().normalize() : dUnit.clone();
  const dLatLon = vectorToLatLon(dUnit);
  const bdPoints = buildArcPoints(dLatLon.lat, dLatLon.lon, midPoint.lat, midPoint.lon);
  const bdGeometry = new THREE.BufferGeometry().setFromPoints(bdPoints);
  const bdMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 });
  alaraMidLine = new THREE.Line(bdGeometry, bdMaterial);
  scene.add(alaraMidLine);

  const markerGeometry = new THREE.SphereGeometry(0.012, 16, 16);
  const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
  alaraMidMarker = new THREE.Mesh(markerGeometry, markerMaterial);
  alaraMidMarker.position.copy(dUnit.clone().multiplyScalar(EARTH_RADIUS + 0.02));
  scene.add(alaraMidMarker);

  const bMarkerGeometry = new THREE.SphereGeometry(0.012, 16, 16);
  const bMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xffd166 });
  alaraBMarker = new THREE.Mesh(bMarkerGeometry, bMarkerMaterial);
  if (midVec) {
    alaraBMarker.position.copy(midVec.clone().multiplyScalar(EARTH_RADIUS + 0.02));
  } else {
    alaraBMarker.position.copy(latLonToVector3(midPoint.lat, midPoint.lon, EARTH_RADIUS + 0.02));
  }
  scene.add(alaraBMarker);

  const perpPoints = [];
  const segments = 128;
  for (let i = 0; i <= segments; i++) {
    const theta = -Math.PI + (i / segments) * (Math.PI * 2);
    const p = dUnit.clone().multiplyScalar(Math.cos(theta))
      .add(axisPerp.clone().multiplyScalar(Math.sin(theta)))
      .normalize()
      .multiplyScalar(EARTH_RADIUS + 0.015);
    perpPoints.push(p);
  }
  const perpGeometry = new THREE.BufferGeometry().setFromPoints(perpPoints);
  const perpMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.35 });
  alaraPerpLine = new THREE.Line(perpGeometry, perpMaterial);
  scene.add(alaraPerpLine);
}

function computeAlaraAlternative(route, grid) {
  const start = latLonToVector3(route.srcLat, route.srcLon, 1).normalize();
  const end = latLonToVector3(route.dstLat, route.dstLon, 1).normalize();
  const originalKm = greatCircleKmFromVectors(start, end);
  const maxKm = originalKm * 1.05;
  const mid = slerpUnit(start, end, 0.5);
  let normal = start.clone().cross(end);
  if (normal.lengthSq() < 1e-6) return null;
  normal.normalize();
  let tangent = normal.clone().cross(mid);
  if (tangent.lengthSq() < 1e-6) return null;
  tangent.normalize();
  let axisPerp = tangent.clone().cross(mid);
  if (axisPerp.lengthSq() < 1e-6) return null;
  axisPerp.normalize();
  if (axisPerp.y > 0) {
    axisPerp.multiplyScalar(-1);
  }

  const candidates = [];
  const steps = 72;
  for (let i = 0; i <= steps; i++) {
    const theta = -Math.PI + (i / steps) * (Math.PI * 2);
    const bVec = mid.clone()
      .multiplyScalar(Math.cos(theta))
      .add(axisPerp.clone().multiplyScalar(Math.sin(theta)))
      .normalize();
    const kmAB = greatCircleKmFromVectors(start, bVec);
    const kmBC = greatCircleKmFromVectors(bVec, end);
    const totalKm = kmAB + kmBC;
    const bLatLon = vectorToLatLon(bVec);
    const dose1 = computeRouteDose({
      srcLat: route.srcLat,
      srcLon: route.srcLon,
      dstLat: bLatLon.lat,
      dstLon: bLatLon.lon,
    }, grid);
    const dose2 = computeRouteDose({
      srcLat: bLatLon.lat,
      srcLon: bLatLon.lon,
      dstLat: route.dstLat,
      dstLon: route.dstLon,
    }, grid);
    const totalDose = dose1.doseMicroSv + dose2.doseMicroSv;
    candidates.push({
      mid: bLatLon,
      midVec: bVec.clone(),
      axisPerp: axisPerp.clone(),
      distanceKm: totalKm,
      doseMicroSv: totalDose,
    });
  }
  const feasible = candidates.filter((c) => c.distanceKm <= maxKm);
  if (feasible.length === 0) return { status: 'none' };
  const underLimit = feasible.filter((c) => c.doseMicroSv <= 500);
  if (underLimit.length === 0) {
    const best = feasible.reduce((acc, cur) => (cur.doseMicroSv < acc.doseMicroSv ? cur : acc), feasible[0]);
    return { status: 'cancel', best };
  }
  const chosen = underLimit.reduce((acc, cur) => (cur.distanceKm < acc.distanceKm ? cur : acc), underLimit[0]);
  return { status: 'reroute', chosen, bestDose: chosen.doseMicroSv };
}

function updateAlaraUI() {
  if (!alaraSection || !alaraContent) return;
  const warning = latestPrediction && latestPrediction.level === 'danger';
  if (!warning || !currentRoute || !radiationGrid) {
    alaraSection.classList.remove('active');
    alaraContent.innerHTML = '';
    clearAlaraAltLine();
    alaraAltRoute = null;
    alaraSelection = null;
    return;
  }

  const originalDose = computeRouteDose(currentRoute, radiationGrid).doseMicroSv;
  if (originalDose < 500) {
    alaraSection.classList.remove('active');
    alaraContent.innerHTML = '';
    clearAlaraAltLine();
    alaraAltRoute = null;
    alaraSelection = null;
    return;
  }

  const result = computeAlaraAlternative(currentRoute, radiationGrid);
  alaraSection.classList.add('active');
  alaraContent.innerHTML = '';

  if (!result || result.status === 'none') {
    alaraContent.innerHTML = `<div>대체 경로를 찾지 못했습니다.</div>`;
    clearAlaraAltLine();
    return;
  }

  if (result.status === 'cancel') {
    alaraAltRoute = result.best;
    alaraContent.innerHTML = `
      <div>최소 예상 총 피폭량: ${result.best.doseMicroSv.toFixed(2)} uSv</div>
      <div class="alara-actions">
        <button class="primary" id="alara-cancel-btn" type="button">Flight Cancel</button>
      </div>
    `;
    clearAlaraAltLine();
    const cancelBtn = document.getElementById('alara-cancel-btn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', () => {
        window.alert('Flight canceled');
      });
    }
    return;
  }

  alaraAltRoute = result.chosen;
  renderAlaraAltLine(currentRoute, result.chosen.mid, result.chosen.axisPerp, result.chosen.midVec);
  alaraSelection = null;
  if (currentRouteLine) currentRouteLine.visible = true;
  if (alaraAltLine) alaraAltLine.visible = true;
  if (alaraMidLine) alaraMidLine.visible = false;
  if (alaraMidMarker) alaraMidMarker.visible = false;
  if (alaraPerpLine) alaraPerpLine.visible = false;
  if (alaraBMarker) alaraBMarker.visible = false;

  const altDose = result.chosen.doseMicroSv;
  const altKm = result.chosen.distanceKm;
  const originalKm = greatCircleKm(currentRoute.srcLat, currentRoute.srcLon, currentRoute.dstLat, currentRoute.dstLon);
  alaraContent.innerHTML = `
    <div class="alara-table">
      <div class="alara-row header">
        <span>Route</span>
        <span>Dose</span>
        <span>Distance</span>
      </div>
      <div class="alara-row selectable" data-route="original">
        <span>Original</span>
        <span>${originalDose.toFixed(2)} uSv</span>
        <span>${originalKm.toFixed(2)} km</span>
      </div>
      <div class="alara-row selectable" data-route="alternative">
        <span>Alternative</span>
        <span>${altDose.toFixed(2)} uSv</span>
        <span>${altKm.toFixed(2)} km</span>
      </div>
    </div>
    <div id="alara-selected" class="alara-selected"></div>
  `;
  const selectableRows = Array.from(alaraContent.querySelectorAll('.alara-row.selectable'));
  const selectedMsg = document.getElementById('alara-selected');
  const applySelection = (selection) => {
    alaraSelection = selection;
    selectableRows.forEach((row) => {
      row.classList.toggle('selected', row.dataset.route === selection);
    });
    if (selection === 'original') {
      if (currentRouteLine) currentRouteLine.visible = true;
      if (alaraAltLine) alaraAltLine.visible = false;
      if (alaraMidLine) alaraMidLine.visible = false;
      if (alaraMidMarker) alaraMidMarker.visible = false;
      if (alaraPerpLine) alaraPerpLine.visible = false;
      if (alaraBMarker) alaraBMarker.visible = false;
      if (selectedMsg) selectedMsg.textContent = 'Selected original route';
      return;
    }
    if (currentRouteLine) currentRouteLine.visible = false;
    if (alaraAltLine) alaraAltLine.visible = true;
    if (alaraMidLine) alaraMidLine.visible = false;
    if (alaraMidMarker) alaraMidMarker.visible = false;
    if (alaraPerpLine) alaraPerpLine.visible = false;
    if (alaraBMarker) alaraBMarker.visible = false;
    if (selectedMsg) selectedMsg.textContent = 'Selected alternative route';
  };
  selectableRows.forEach((row) => {
    row.addEventListener('click', () => {
      applySelection(row.dataset.route);
    });
  });
}

function createCrewRow(code = '') {
  const row = document.createElement('div');
  row.className = 'crew-row';
  const input = document.createElement('input');
  input.type = 'text';
  input.inputMode = 'numeric';
  input.maxLength = 3;
  input.placeholder = 'Crew code (3 digits)';
  input.value = code;
  const remove = document.createElement('button');
  remove.type = 'button';
  remove.textContent = 'Remove';
  remove.addEventListener('click', () => row.remove());
  row.appendChild(input);
  row.appendChild(remove);
  return row;
}

function syncLogTimeInput() {
  const usingCurrent = useCurrentTime.checked;
  logDatetimeInput.disabled = usingCurrent;
  if (usingCurrent) {
    logDatetimeInput.value = datetimeInput.value;
  }
}

function openLogModal() {
  if (getCurrentRole() !== 'admin') return;
  crewListEl.innerHTML = '';
  crewListEl.appendChild(createCrewRow());
  logDatetimeInput.value = datetimeInput.value;
  useCurrentTime.checked = true;
  syncLogTimeInput();
  logModal.classList.add('open');
  logModal.setAttribute('aria-hidden', 'false');
}

function closeLogModal() {
  logModal.classList.remove('open');
  logModal.setAttribute('aria-hidden', 'true');
}

function showLoading() {
  loadingCount += 1;
  loadingOverlay.classList.add('active');
  loadingOverlay.setAttribute('aria-hidden', 'false');
}

function hideLoading() {
  loadingCount = Math.max(0, loadingCount - 1);
  if (loadingCount === 0) {
    loadingOverlay.classList.remove('active');
    loadingOverlay.setAttribute('aria-hidden', 'true');
  }
}

/* ============================
   NEW: Radiation overlay
   ============================ */

const API_URL = "http://3.39.244.94:8000/radiation_grid";

async function fetchRadiationGridFromEC2(dateUTC) {
  const year = dateUTC.getUTCFullYear();
  const month = dateUTC.getUTCMonth() + 1;
  const day = dateUTC.getUTCDate();

  let goesProton = 0.0;
  const sepMap = await loadSepPredictions();
  if (sepMap && sepMap.size > 0) {
    const key = formatDateKey(dateUTC);
    const entry = sepMap.get(key);
    if (entry && Number.isFinite(entry.expectedSep)) {
      goesProton = entry.expectedSep;
    }
  }

  const payload = {
    year: year,
    month: month,
    day: day,
    altitude: 30000,
    g_parameter: -1.5,
    goes_proton: goesProton,
    lat_step: 10.0,
    lon_step: 10.0
  };

  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 8000);
  let res;
  try {
    res = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      signal: controller.signal,
    });
  } finally {
    clearTimeout(timeoutId);
  }

  if (!res.ok) {
    throw new Error(`Radiation API failed: ${res.status}`);
  }

  const grid = await res.json();

  // values: Array → Float32Array로 변환 (중요)
  grid.values = new Float32Array(grid.values);

  return grid;
}




const RADIATION_SCALE_MIN = 0;
const RADIATION_SCALE_MID = 45;
const RADIATION_SCALE_MAX = 45;

// color ramp with fixed thresholds (0 -> 45 -> 81+)
// returns [r,g,b] 0..255
function colorForValue(v) {
  const clamped = Math.min(RADIATION_SCALE_MAX, Math.max(RADIATION_SCALE_MIN, v));
  const t = (clamped - RADIATION_SCALE_MIN)
    / Math.max(1e-9, (RADIATION_SCALE_MAX - RADIATION_SCALE_MIN));

  const stops = [
    { t: 0.0, c: [ 42, 108, 255] }, // blue
    { t: 1.0, c: [255,  59,  59] }, // red (45+)
  ];

  let i = 0;
  while (i < stops.length - 2 && t > stops[i + 1].t) i++;

  const s0 = stops[i];
  const s1 = stops[i + 1];
  const localT = (t - s0.t) / Math.max(1e-9, (s1.t - s0.t));

  const r = Math.round(s0.c[0] + (s1.c[0] - s0.c[0]) * localT);
  const g = Math.round(s0.c[1] + (s1.c[1] - s0.c[1]) * localT);
  const b = Math.round(s0.c[2] + (s1.c[2] - s0.c[2]) * localT);
  return [r, g, b];
}

function buildRadiationTexture(grid) {
  const { width, height, values } = grid;

  // RGBA texture
  const data = new Uint8Array(width * height * 4);

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const v = values[y * width + x];
      const [r, g, b] = colorForValue(v);

      const idx = (y * width + x) * 4;
      data[idx + 0] = r;
      data[idx + 1] = g;
      data[idx + 2] = b;

      // Alpha: keep it visible but not too aggressive.
      // Optionally make higher radiation slightly more opaque.
      const t = (Math.min(RADIATION_SCALE_MAX, Math.max(RADIATION_SCALE_MIN, v)) - RADIATION_SCALE_MIN)
        / Math.max(1e-9, (RADIATION_SCALE_MAX - RADIATION_SCALE_MIN));
      const alpha = 70 + Math.round(120 * Math.min(1, Math.max(0, t))); // 70..190
      data[idx + 3] = alpha;
    }
  }

  const tex = new THREE.DataTexture(data, width, height, THREE.RGBAFormat);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = THREE.RepeatWrapping;
  tex.wrapT = THREE.ClampToEdgeWrapping;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.needsUpdate = true;
  return tex;
}

// Create atmosphere-like overlay sphere
const RADIATION_RADIUS = EARTH_RADIUS + 0.035;
const radiationGeometry = new THREE.SphereGeometry(RADIATION_RADIUS, 128, 128);

let radiationTexture = null;
let radiationGrid = null;
const radiationMaterial = new THREE.MeshBasicMaterial({
  map: null,
  transparent: true,
  opacity: 0.70,     // base opacity; alpha channel also applies
  depthWrite: false, // so it doesn't "cut holes" in earth
  blending: THREE.NormalBlending,
});
const radiationShell = new THREE.Mesh(radiationGeometry, radiationMaterial);
radiationShell.renderOrder = 2;
scene.add(radiationShell);

async function updateRadiationOverlay(dateUTC) {
  try {
    const grid = await fetchRadiationGridFromEC2(dateUTC);
  const tex = buildRadiationTexture(grid);

  if (radiationTexture) {
    radiationTexture.dispose();
  }

  radiationTexture = tex;
  radiationMaterial.map = radiationTexture;
  radiationMaterial.needsUpdate = true;
  radiationGrid = grid;

    legendMinEl.textContent = `${RADIATION_SCALE_MIN.toFixed(0)} uSv/h`;
    legendMaxEl.textContent = `${RADIATION_SCALE_MAX.toFixed(0)} uSv/h`;
    return grid;
  } catch (err) {
    console.error("Radiation fetch failed:", err);
    return null;
  }
}

async function fetchRadiationForDate(dateUTC) {
  showLoading();
  try {
    const grid = await updateRadiationOverlay(dateUTC);
    updateAlaraUI();
    return grid;
  } finally {
    hideLoading();
  }
}


toggleRadiation.addEventListener('change', () => {
  radiationShell.visible = toggleRadiation.checked;
});

/* ============================
   NEW: init + update hooks
   ============================ */

function setInitialDateTime() {
  const initial = new Date(Date.UTC(2000, 0, 1, 0, 0, 0));
  datetimeInput.value = formatDateTimeLocalUTC(initial);
  simulatedTime = initial;
  lastRadiationDateKey = formatDateOnlyKey(initial);
  updateSunFromDate(initial);
  fetchRadiationForDate(initial);
  updateSepPrediction(initial);
}


let isTimeRunning = true;
const TIME_SCALE = 1800;
let simulatedTime = null;
let lastFrameTime = performance.now();
let lastUiUpdate = 0;
let lastRadiationDateKey = null;

function formatDateTimeLocalUTC(date) {
  const pad = (n) => String(n).padStart(2, '0');
  return `${date.getUTCFullYear()}-${pad(date.getUTCMonth() + 1)}-${pad(date.getUTCDate())}T${pad(date.getUTCHours())}:${pad(date.getUTCMinutes())}:${pad(date.getUTCSeconds())}`;
}

function formatDateOnlyKey(date) {
  const y = date.getUTCFullYear();
  const m = String(date.getUTCMonth() + 1).padStart(2, '0');
  const d = String(date.getUTCDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
}

function updateTimeFlowFrame(nowMs) {
  if (!simulatedTime) {
    simulatedTime = parseDateTimeLocalAsUTC(datetimeInput.value) || new Date();
  }
  const elapsedMs = nowMs - lastFrameTime;
  lastFrameTime = nowMs;

  if (!isTimeRunning) return;

  simulatedTime = new Date(simulatedTime.getTime() + elapsedMs * TIME_SCALE);

  updateSunFromDate(simulatedTime);

  const dateKey = formatDateOnlyKey(simulatedTime);
  if (dateKey !== lastRadiationDateKey) {
    fetchRadiationForDate(simulatedTime);
    lastRadiationDateKey = dateKey;
  }

  if (nowMs - lastUiUpdate > 250) {
    datetimeInput.value = formatDateTimeLocalUTC(simulatedTime);
    updateSepPrediction(simulatedTime);
  if (currentRoute && radiationGrid) {
    const dose = computeRouteDose(currentRoute, radiationGrid);
    routeDistanceEl.textContent = `${dose.distanceKm.toFixed(1)} km`;
    routeTimeEl.textContent = `${dose.hours.toFixed(2)} h`;
    routeDoseEl.textContent = `${dose.doseMicroSv.toFixed(2)} uSv (${dose.doseSv.toExponential(3)} Sv)`;
    }
    updateAlaraUI();
    lastUiUpdate = nowMs;
  }
}

toggleTimeFlow.addEventListener('click', () => {
  isTimeRunning = !isTimeRunning;
  toggleTimeFlow.textContent = isTimeRunning ? 'Pause' : 'Resume';
  lastFrameTime = performance.now();
});

function applyDateTimeSelection(date) {
  simulatedTime = date;
  lastRadiationDateKey = formatDateOnlyKey(date);
    updateSunFromDate(date);
  fetchRadiationForDate(date);
  updateSepPrediction(date);
    if (currentRoute && radiationGrid) {
      const dose = computeRouteDose(currentRoute, radiationGrid);
      routeDistanceEl.textContent = `${dose.distanceKm.toFixed(1)} km`;
      routeTimeEl.textContent = `${dose.hours.toFixed(2)} h`;
      routeDoseEl.textContent = `${dose.doseMicroSv.toFixed(2)} uSv (${dose.doseSv.toExponential(3)} Sv)`;
    }
  updateAlaraUI();
}


useCurrentTime.addEventListener('change', () => {
  syncLogTimeInput();
});

addCrewBtn.addEventListener('click', () => {
  crewListEl.appendChild(createCrewRow());
});

cancelLogBtn.addEventListener('click', () => {
  closeLogModal();
});

document.addEventListener('keydown', (event) => {
  if (event.key !== 'Escape') return;
  if (logModal.classList.contains('open')) {
    closeLogModal();
  }
});

saveLogBtn.addEventListener('click', async () => {
  if (getCurrentRole() !== 'admin') return;
  if (!currentRoute) {
    window.alert('먼저 노선을 선택하고 Show를 눌러주세요.');
    return;
  }
  const crewCodes = Array.from(crewListEl.querySelectorAll('input'))
    .map((input) => input.value.trim())
    .filter(Boolean);
  if (crewCodes.length === 0) {
    window.alert('탑승 승무원 코드를 최소 1명 입력해주세요.');
    return;
  }
  const invalidCode = crewCodes.find((code) => !/^\d{3}$/.test(code));
  if (invalidCode) {
    window.alert('Crew code는 세자리 숫자여야 합니다.');
    return;
  }
  const sourceValue = useCurrentTime.checked ? datetimeInput.value : logDatetimeInput.value;
  const dateUTC = parseDateTimeLocalAsUTC(sourceValue) || new Date();

  if (!radiationGrid) {
    await fetchRadiationForDate(dateUTC);
  }
  if (!radiationGrid) {
    window.alert('방사선 데이터를 불러오지 못했습니다. 잠시 후 다시 시도해주세요.');
    return;
  }

  let dose = computeRouteDose(currentRoute, radiationGrid);
  let routeType = 'original';
  if (alaraSelection === 'alternative' && alaraAltRoute) {
    routeType = 'alternative';
    dose = computeAlternativeDose(currentRoute, alaraAltRoute, radiationGrid);
  }

  const entry = {
    id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    dateUTC: dateUTC.toISOString(),
    dateDisplay: sourceValue,
    depart: departSelect.value,
    arrive: arriveSelect.value,
    srcLat: currentRoute.srcLat,
    srcLon: currentRoute.srcLon,
    dstLat: currentRoute.dstLat,
    dstLon: currentRoute.dstLon,
    distanceKm: dose.distanceKm,
    hours: dose.hours,
    doseMicroSv: dose.doseMicroSv,
    doseSv: dose.doseSv,
    routeType,
    midLat: routeType === 'alternative' ? alaraAltRoute.mid.lat : null,
    midLon: routeType === 'alternative' ? alaraAltRoute.mid.lon : null,
    crewCodes,
    addedBy: getCurrentUser(),
  };

  const records = loadFlightRecords();
  records.push(entry);
  saveFlightRecords(records);
  closeLogModal();
  window.alert('Saved.');
});

document.addEventListener('keydown', (event) => {
  if (event.code !== 'Space') return;
  const target = event.target;
  if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable)) {
    return;
  }
  event.preventDefault();
  toggleTimeFlow.click();
});

datetimeInput.addEventListener('change', () => {
  const value = datetimeInput.value;
  if (!value) return;
  const date = parseDateTimeLocalAsUTC(value);
  if (date && !Number.isNaN(date.getTime())) {
    applyDateTimeSelection(date);
  }
});

setInitialDateTime();
applyRoleUI();

// DATA LOAD (unchanged)
let data;
try {
  const res = await fetch('./data/capitals_routes.json');
  if (!res.ok) {
    throw new Error(`Failed to load data: ${res.status}`);
  }
  data = await res.json();
} catch (err) {
  console.error(err);
  window.alert('데이터를 불러오지 못했습니다. 로컬 서버(http://localhost:8001)로 열어주세요.');
  throw err;
}

const allCapitals = data.capitals.slice().sort();
const capitalRoutes = new Map();
const reverseCapitalRoutes = new Map();
let currentRoute = null;

for (const route of data.routes) {
  const srcCapital = data.capitalByAirport[route.src];
  const dstCapital = data.capitalByAirport[route.dst];
  if (!srcCapital || !dstCapital) continue;

  if (!capitalRoutes.has(srcCapital)) capitalRoutes.set(srcCapital, new Set());
  if (!reverseCapitalRoutes.has(dstCapital)) reverseCapitalRoutes.set(dstCapital, new Set());
  capitalRoutes.get(srcCapital).add(dstCapital);
  reverseCapitalRoutes.get(dstCapital).add(srcCapital);
}

function rebuildSelect(select, options, selectedValue, placeholder) {
  select.innerHTML = '';
  const first = new Option(placeholder, '');
  first.selected = selectedValue === '';
  select.add(first);
  for (const name of options) {
    const opt = new Option(name, name);
    if (name === selectedValue) opt.selected = true;
    select.add(opt);
  }
}

function updateArriveOptions() {
  const depart = departSelect.value;
  const allowed = depart ? Array.from(capitalRoutes.get(depart) || []) : allCapitals;
  allowed.sort();
  const current = arriveSelect.value;
  rebuildSelect(arriveSelect, allowed, allowed.includes(current) ? current : '', 'Select');
}

function updateDepartOptions() {
  const arrive = arriveSelect.value;
  const allowed = arrive ? Array.from(reverseCapitalRoutes.get(arrive) || []) : allCapitals;
  allowed.sort();
  const current = departSelect.value;
  rebuildSelect(departSelect, allowed, allowed.includes(current) ? current : '', 'Select');
}

rebuildSelect(departSelect, allCapitals, '', 'Select');
rebuildSelect(arriveSelect, allCapitals, '', 'Select');

departSelect.addEventListener('change', () => {
  updateArriveOptions();
});

arriveSelect.addEventListener('change', () => {
  updateDepartOptions();
});

showBtn.addEventListener('click', async () => {
  const depart = departSelect.value;
  const arrive = arriveSelect.value;
  if (!depart || !arrive) {
    window.alert('depart와 arrive를 모두 선택해주세요.');
    return;
  }

  let best = null;
  let bestDist = Infinity;

  for (const route of data.routes) {
    const srcCapital = data.capitalByAirport[route.src];
    const dstCapital = data.capitalByAirport[route.dst];
    if (srcCapital !== depart || dstCapital !== arrive) continue;

    const dist = greatCircleKm(route.srcLat, route.srcLon, route.dstLat, route.dstLon);
    if (dist < bestDist) {
      bestDist = dist;
      best = route;
    }
  }

  if (!best) {
    window.alert('선택한 수도 간에 노선이 없습니다.');
    return;
  }

  drawRoute(best);
  setRouteCenteredView(best);
  currentRoute = best;
  isRouteSideView = false;
  changeViewBtn.textContent = 'Change view';
  changeViewBtn.style.display = 'inline-flex';
  if (currentRouteLine) currentRouteLine.visible = true;
  clearAlaraAltLine();

  const baseDistanceKm = greatCircleKm(best.srcLat, best.srcLon, best.dstLat, best.dstLon);
  const baseHours = baseDistanceKm / 900;
  routeDistanceEl.textContent = `${baseDistanceKm.toFixed(1)} km`;
  routeTimeEl.textContent = `${baseHours.toFixed(2)} h`;

  if (!radiationGrid) {
    const now = parseDateTimeLocalAsUTC(datetimeInput.value) || new Date();
    await fetchRadiationForDate(now);
  }
  if (radiationGrid) {
    const dose = computeRouteDose(best, radiationGrid);
    routeDoseEl.textContent = `${dose.doseMicroSv.toFixed(2)} uSv (${dose.doseSv.toExponential(3)} Sv)`;
  } else {
    routeDoseEl.textContent = '-';
  }
  updateAlaraUI();
});

changeViewBtn.addEventListener('click', () => {
  if (!currentRoute) return;
  if (!isRouteSideView) {
    setRouteSideView(currentRoute);
    isRouteSideView = true;
    changeViewBtn.textContent = 'Reset view';
  } else {
    resetCameraView();
    isRouteSideView = false;
    changeViewBtn.textContent = 'Change view';
  }
});

addToLogBtn.addEventListener('click', () => {
  if (!isLoggedIn()) {
    window.alert('로그인 후 Add to log를 사용할 수 있습니다.');
    return;
  }
  if (getCurrentRole() !== 'admin') {
    window.alert('관리자만 비행 기록을 추가할 수 있습니다.');
    return;
  }
  openLogModal();
});

profileBtn.addEventListener('click', () => {
  const isOpen = profileMenu.style.display === 'flex';
  profileMenu.style.display = isOpen ? 'none' : 'flex';
});

profilePageLink.addEventListener('click', () => {
  const role = getCurrentRole();
  window.location.href = role === 'admin' ? './status.html' : './my_page.html';
});

logoutButton.addEventListener('click', () => {
  localStorage.removeItem(LOGIN_STORAGE_KEY);
  localStorage.removeItem(CURRENT_USER_KEY);
  localStorage.removeItem(CURRENT_ROLE_KEY);
  window.location.href = './index.html';
});

document.addEventListener('click', (event) => {
  if (!profileMenu.contains(event.target) && !profileBtn.contains(event.target)) {
    profileMenu.style.display = 'none';
  }
});

// LOOP
function animate() {
  requestAnimationFrame(animate);
  updateTimeFlowFrame(performance.now());
  if (!updateCameraTransition()) {
  controls.update();
  }
  sky.rotation.y = earth.rotation.y;
  renderer.render(scene, camera);
}
animate();

// RESIZE
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
